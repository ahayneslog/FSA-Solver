<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Thu Mar 18 19:24:12 GMT 2004 -->
<TITLE>
Query (JPL-3.0.3-alpha API)
</TITLE>

<META NAME="keywords" CONTENT="jpl.Query class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Query (JPL-3.0.3-alpha API)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Query.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../jpl/JVoid.html" title="class in jpl"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../jpl/Term.html" title="class in jpl"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Query.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jpl</FONT>
<BR>
Class Query</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by"><B>jpl.Query</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.util.Enumeration</DD>
</DL>
<HR>
<DL>
<DT>public class <B>Query</B><DT>extends java.lang.Object<DT>implements java.util.Enumeration</DL>

<P>
A Query instance is created by an application in order to query the Prolog engine.
 It is initialised with a
 Compound (or Atom) denoting the goal which is to be called, and also contains assorted private state
 relating to solutions.  In some future version, it will contain details of the module
 in which the goal is to be called.<p>
 A Query is either open or closed: when closed, it has no connection to the Prolog engine;
 when open, it is linked to an active goal within the Prolog engine.
 Only one Query can be open at any one time<p>
 The Query class implements the Enumeration interface, and it is
 through this interface that one obtains successive solutions.  The Enumeration
 hasMoreElements() method returns true if the call or redo succeeded (otherwise
 false), and if the call or redo did succeed, the nextElement() method returns
 a Hashtable representing variable bindings; the elements in the
 Hashtable are Terms, indexed by the Variables with which they are associated.
 For example, if <i>p(a)</i> and <i>p(b)</i> are facts in the Prolog
 database, then the following is equivalent to printing all
 the solutions to the Prolog query <i>p(X)</i>:
 <pre>
 Variable X = new Variable();
 Term arg[] = { X };
 Query    q = new Query( "p", arg );
 
 while ( q.hasMoreElements() ){
     Term bound_to_x = ((Hashtable)q.nextElement()).get( X );
     System.out.println( bound_to_x );
 }
 </pre>
 Make sure to close the Query (using the rewind() method) if you do not need
 any further solutions which it may have.
 It is safe (although redundant) to close a Query whose solutions are already exhausted,
 or which is already closed.
 
 To obtain just one solution from a Query, use the oneSolution() method.
 
 To obtain all solutions, use the allSolutions() method.
 
 To determine merely whether the Query is provable,
 use the query() method (soon to be deprecated in favour of hasSolution()).
 (i.e. has at least one solution).
 <hr>
 <i>
 Copyright (C) 2004  Paul Singleton<p>
 Copyright (C) 1998  Fred Dushin
 <p>
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.
 <p>
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Library Public License for more details.<p>
 </i>
 <hr>
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>$Revision: 1.2 $</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(java.lang.String)">Query</A></B>(java.lang.String&nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor builds a Query from the given Prolog source text</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(java.lang.String, jpl.Term)">Query</A></B>(java.lang.String&nbsp;text,
      <A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(java.lang.String, jpl.Term[])">Query</A></B>(java.lang.String&nbsp;text,
      <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If text denotes an atom, this constructor is shorthand for
 <font face="monospace">new Query(new Compound(name,args))</font>,
 but if text denotes a term containing N query symbols
 and there are N args, each query is replaced by its corresponding arg
 to provide the new Query's goal.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../jpl/Query.html#Query(jpl.Term)">Query</A></B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This constructor creates a Query whose goal is the specified Term.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#abort()">abort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#allSolutions()">allSolutions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calls the Query's goal to exhaustion and returns an array containing every solution
 (in the order in which they were found).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#args()">args</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use .goal().args() instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#close()">close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is used to close an open query so that the query
 may be re-run, even if the Query's Enumeration has more 
 elements.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#debugString()">debugString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#getSolution()">getSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns a java.util.Hashtable, which represents
 a set of bindings from the names of query variables to terms within the solution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#getSubstWithNameVars()">getSubstWithNameVars</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../jpl/Compound.html" title="class in jpl">Compound</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#goal()">goal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the Compound (hence perhaps an Atom) which is the goal of this Query</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasMoreElements()">hasMoreElements</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method is completes the java.util.Enumeration
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasMoreSolutions()">hasMoreSolutions</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#hasSolution()">hasSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPL will attempt to call this Query's goal within the attached Prolog engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#name()">name</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use .goal().name() instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nextElement()">nextElement</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method completes the java.util.Enumeration
 interface.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#nextSolution()">nextSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns a java.util.Hashtable, which represents
 a binding from the names of query variables to terms within the solution.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Hashtable</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#oneSolution()">oneSolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the first solution, if any, as a (possibly empty) Hashtable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#open()">open</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#query()">query</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use .hasSolution() instead.
 JPL will attempt to call this Query's goal within the attached Prolog engine.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#rewind()">rewind</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../jpl/Query.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the String representation of a Query.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Query(jpl.Term)"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(<A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;t)</PRE>
<DL>
<DD>This constructor creates a Query whose goal is the specified Term.
 The Query is initially closed.
 <b>NB</b>  Creating an instance of the Query class does not
 result in a call to a Prolog engine.
 <b>NB</b>  The goal can be an Atom (Atom extends Compound), but cannot be an instance
 of jpl.Float, jpl.Integer or jpl.Variable.
<P>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the goal of this Query</DL>
<HR>

<A NAME="Query(java.lang.String, jpl.Term[])"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(java.lang.String&nbsp;text,
             <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[]&nbsp;args)</PRE>
<DL>
<DD>If text denotes an atom, this constructor is shorthand for
 <font face="monospace">new Query(new Compound(name,args))</font>,
 but if text denotes a term containing N query symbols
 and there are N args, each query is replaced by its corresponding arg
 to provide the new Query's goal.
<P>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the name of the principal functor of this Query's goal<DD><CODE>args</CODE> - the arguments of this Query's goal</DL>
<HR>

<A NAME="Query(java.lang.String, jpl.Term)"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(java.lang.String&nbsp;text,
             <A HREF="../jpl/Term.html" title="class in jpl">Term</A>&nbsp;arg)</PRE>
<DL>
</DL>
<HR>

<A NAME="Query(java.lang.String)"><!-- --></A><H3>
Query</H3>
<PRE>
public <B>Query</B>(java.lang.String&nbsp;text)</PRE>
<DL>
<DD>This constructor builds a Query from the given Prolog source text
<P>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Prolog source text of this Query</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="name()"><!-- --></A><H3>
name</H3>
<PRE>
public final java.lang.String <B>name</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use .goal().name() instead.</I>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the name of this Query's goal (redundant, deprecated)</DL>
</DD>
</DL>
<HR>

<A NAME="args()"><!-- --></A><H3>
args</H3>
<PRE>
public final <A HREF="../jpl/Term.html" title="class in jpl">Term</A>[] <B>args</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use .goal().args() instead.</I>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the arguments of this Query's goal (redundant, deprecated)</DL>
</DD>
</DL>
<HR>

<A NAME="goal()"><!-- --></A><H3>
goal</H3>
<PRE>
public final <A HREF="../jpl/Compound.html" title="class in jpl">Compound</A> <B>goal</B>()</PRE>
<DL>
<DD>Returns the Compound (hence perhaps an Atom) which is the goal of this Query
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a Term representing the goal of this Query</DL>
</DD>
</DL>
<HR>

<A NAME="hasMoreSolutions()"><!-- --></A><H3>
hasMoreSolutions</H3>
<PRE>
public final boolean <B>hasMoreSolutions</B>()</PRE>
<DL>
<DD>This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.  It is designed to be used
 with the nextSolution() method to retrieve one or
 more substitutions in the form of Hashtables.  To iterate through
 all the solutions to a Query, for example, one might write
 <pre>
 Query q = // obtain Query reference
 while ( q.hasMoreSolutions() ){
     Hashtable solution = q.nextSolution();
     // process solution...
 }
 </pre>
 To ensure thread-safety, you should wrap sequential calls to
 this method in a synchronized block, using the static
 lock method to obtain the monitor.
 <pre>
 Query q = // obtain Query reference
 synchronized ( jpl.Query.lock() ){
     while ( q.hasMoreElements() ){
          Hashtable solution = q.nextSolution();
          // process solution...
     }
 }
 </pre>
 <p>
 If this method is called on an already-open Query,
 or while another Query is open, then a
 QueryInProgressException will be thrown, containing a reference to the currently
 open Query.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the Prolog query succeeds; otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="open()"><!-- --></A><H3>
open</H3>
<PRE>
public final void <B>open</B>()</PRE>
<DL>
<DD>This method returns true if JPL was able to initiate a "call" of this
 Query within the Prolog engine.  It is designed to be used
 with the getSolution() and close() methods to retrieve one or
 more substitutions in the form of Hashtables.
 To ensure thread-safety, you should wrap sequential calls to
 this method in a synchronized block, using the static
 lock method to obtain the monitor.
 <pre>
 Query q = // obtain Query reference
 synchronized ( jpl.Query.lock() ){
     while ( q.hasMoreElements() ){
          Hashtable solution = q.nextSolution();
          // process solution...
     }
 }
 </pre>
 <p>
 If this method is called on an already-open Query,
 or if the query cannot be set up for whatever reason,
 then a JPLException will be thrown.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSolution()"><!-- --></A><H3>
getSolution</H3>
<PRE>
public final java.util.Hashtable <B>getSolution</B>()</PRE>
<DL>
<DD>This method returns a java.util.Hashtable, which represents
 a set of bindings from the names of query variables to terms within the solution.
 The Hashtable contains instances of Terms, keyed on those
 Variables which were referenced in this Query's goal.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable,
 say, named X, one can obtain the Term bound to X in the solution
 by looking up X in the Hashtable.
 <pre>
 Variable X = new Variable();
 Query q = // obtain Query reference (with X in the Term array)
 while ( q.hasMoreSolutions() ){
     Hashtable solution = q.nextSolution();
     // make t the Term bound to X in the solution
     Term t = (Term)solution.get( X );
     // ...
 }
 </pre>
 Programmers should obey the following rules when using this method.
 <menu>
 <li> The nextSolution() method should only be called after the
 hasMoreSolutions() method returns true; otherwise a JPLException
 will be raised, indicating that no Query is in progress.
 <li> The nextSolution() and hasMoreSolutions() should be called
 in the same thread of execution, at least for a given Query
 instance.
 <li> The nextSolution() method should not be called while
 another Thread is in the process of evaluating a Query.  The
 JPL High-Level interface is designed to be thread safe, and
 is thread-safe as long as the previous two rules are obeyed.
 </menu>
 
 This method will throw a JPLException if no query is in progress.
 It will throw a QueryInProgressException if another Query
 (besides this one) is in progress while this method is called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A Hashtable representing a substitution, or null</DL>
</DD>
</DL>
<HR>

<A NAME="getSubstWithNameVars()"><!-- --></A><H3>
getSubstWithNameVars</H3>
<PRE>
public final java.util.Hashtable <B>getSubstWithNameVars</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextSolution()"><!-- --></A><H3>
nextSolution</H3>
<PRE>
public final java.util.Hashtable <B>nextSolution</B>()</PRE>
<DL>
<DD>This method returns a java.util.Hashtable, which represents
 a binding from the names of query variables to terms within the solution.
 The Hashtable contains instances of Terms, keyed on those
 Variables which were referenced in this Query's goal.
 <p>
 For example, if a Query has an occurrence of a jpl.Variable,
 say, named X, one can obtain the Term bound to X in the solution
 by looking up X in the Hashtable.
 <pre>
 Variable X = new Variable();
 Query q = // obtain Query reference (with X in the Term array)
 while ( q.hasMoreSolutions() ){
     Hashtable solution = q.nextSolution();
     // make t the Term bound to X in the solution
     Term t = (Term)solution.get( X );
     // ...
 }
 </pre>
 Programmers should obey the following rules when using this method.
 <menu>
 <li> The nextSolution() method should only be called after the
 hasMoreSolutions() method returns true; otherwise a JPLException
 will be raised, indicating that no Query is in progress.
 <li> The nextSolution() and hasMoreSolutions() should be called
 in the same thread of execution, at least for a given Query
 instance.
 <li> The nextSolution() method should not be called while
 another Thread is in the process of evaluating a Query.  The
 JPL High-Level interface is designed to be thread safe, and
 is thread-safe as long as the previous two rules are obeyed.
 </menu>
 
 This method will throw a JPLException if no query is in progress.
 It will throw a QueryInProgressException if another Query
 (besides this one) is in progress while this method is called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A Hashtable representing a substitution.</DL>
</DD>
</DL>
<HR>

<A NAME="hasMoreElements()"><!-- --></A><H3>
hasMoreElements</H3>
<PRE>
public final boolean <B>hasMoreElements</B>()</PRE>
<DL>
<DD>This method is completes the java.util.Enumeration
 interface.  It is a wrapper for hasMoreSolutions.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>hasMoreElements</CODE> in interface <CODE>java.util.Enumeration</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the Prolog query succeeds; false, o/w.</DL>
</DD>
</DL>
<HR>

<A NAME="nextElement()"><!-- --></A><H3>
nextElement</H3>
<PRE>
public final java.lang.Object <B>nextElement</B>()</PRE>
<DL>
<DD>This method completes the java.util.Enumeration
 interface.  It is a wrapper for nextSolution.
 <p>
 This method will throw a QueryInProgressException if another Query
 (besides this one) is in progress while this method is called.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE>nextElement</CODE> in interface <CODE>java.util.Enumeration</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A Hashtable representing a substitution.</DL>
</DD>
</DL>
<HR>

<A NAME="rewind()"><!-- --></A><H3>
rewind</H3>
<PRE>
public final void <B>rewind</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A><H3>
close</H3>
<PRE>
public final void <B>close</B>()</PRE>
<DL>
<DD>This method is used to close an open query so that the query
 may be re-run, even if the Query's Enumeration has more 
 elements.  Calling rewind() on an exhausted Enumeration has
 no effect.<p>
 
 Here is a way to get the first three solutions to a Query,
 while subsequently being able to use the same Query object to
 obtain new solutions:
 <pre>
 Query q = new Query( predicate, args );
 int i = 0;
 for ( int i = 0; i < 3 && q.hasMoreSolutions();  ++i ){
     Hasthable sub = (Hashtable) q.nextSolution();
     ...
 }
 q.close();
 </pre><p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="allSolutions()"><!-- --></A><H3>
allSolutions</H3>
<PRE>
public final java.util.Hashtable[] <B>allSolutions</B>()</PRE>
<DL>
<DD>calls the Query's goal to exhaustion and returns an array containing every solution
 (in the order in which they were found).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>an array of Hashtables (possibly none), each of which is a solution
 (in the order in which they were found) of the Query.
 <b>NB</b> in JPL 1.0.1, this method returned null when a Query had no solutions;
 in JPL 2.x.x it returns an emprt array (thus the length of the array is, in every case,
 the quantity of solutions).<p>
 
 This method will throw a QueryInProgressException if this or another Query
 is already open.<DT><B>See Also:</B><DD><A HREF="../jpl/Query.html#hasMoreElements()"><CODE>hasMoreElements()</CODE></A>, 
<A HREF="../jpl/Query.html#nextElement()"><CODE>nextElement()</CODE></A>, 
<A HREF="../jpl/Query.html#hasMoreSolutions()"><CODE>hasMoreSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#nextSolution()"><CODE>nextSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#rewind()"><CODE>rewind()</CODE></A>, 
<A HREF="../jpl/Query.html#oneSolution()"><CODE>oneSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#allSolutions()"><CODE>allSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#query()"><CODE>query()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="oneSolution()"><!-- --></A><H3>
oneSolution</H3>
<PRE>
public final java.util.Hashtable <B>oneSolution</B>()</PRE>
<DL>
<DD>Returns the first solution, if any, as a (possibly empty) Hashtable.
 
 This method will throw a JPLException if this Query
 is already open, and the Query will remain open as before.
 Otherwise, upon return, the Query will be closed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the first solution, if the query has one, as a (possibly empty) Hashtable.
 If the return value is null, this means that the Query has no solutions.<p><DT><B>See Also:</B><DD><A HREF="../jpl/Query.html#hasMoreElements()"><CODE>hasMoreElements()</CODE></A>, 
<A HREF="../jpl/Query.html#nextElement()"><CODE>nextElement()</CODE></A>, 
<A HREF="../jpl/Query.html#hasMoreSolutions()"><CODE>hasMoreSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#nextSolution()"><CODE>nextSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#rewind()"><CODE>rewind()</CODE></A>, 
<A HREF="../jpl/Query.html#oneSolution()"><CODE>oneSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#allSolutions()"><CODE>allSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#query()"><CODE>query()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="query()"><!-- --></A><H3>
query</H3>
<PRE>
public final boolean <B>query</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use .hasSolution() instead.
 JPL will attempt to call this Query's goal within the attached Prolog engine.</I>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the provability of the Query, i.e. 'true' if it has at least
 one solution, 'false' if the call fails without finding a solution.<p>
 
 Only the first solution (if there is one) will be found;
 any bindings will be discarded, and the Query will be closed.<p>
 This method will throw a QueryInProgressException if this or another Query
 is already open.<DT><B>See Also:</B><DD><A HREF="../jpl/Query.html#hasMoreElements()"><CODE>hasMoreElements()</CODE></A>, 
<A HREF="../jpl/Query.html#nextElement()"><CODE>nextElement()</CODE></A>, 
<A HREF="../jpl/Query.html#hasMoreSolutions()"><CODE>hasMoreSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#nextSolution()"><CODE>nextSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#rewind()"><CODE>rewind()</CODE></A>, 
<A HREF="../jpl/Query.html#oneSolution()"><CODE>oneSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#allSolutions()"><CODE>allSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#query()"><CODE>query()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="hasSolution()"><!-- --></A><H3>
hasSolution</H3>
<PRE>
public final boolean <B>hasSolution</B>()</PRE>
<DL>
<DD>JPL will attempt to call this Query's goal within the attached Prolog engine.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the provability of the Query, i.e. 'true' if it has at least
 one solution, 'false' if the call fails without finding a solution.<p>
 
 Only the first solution (if there is one) will be found;
 any bindings will be discarded, and the Query will be closed.<p>
 This method will throw a QueryInProgressException if this or another Query
 is already open.<DT><B>See Also:</B><DD><A HREF="../jpl/Query.html#hasMoreElements()"><CODE>hasMoreElements()</CODE></A>, 
<A HREF="../jpl/Query.html#nextElement()"><CODE>nextElement()</CODE></A>, 
<A HREF="../jpl/Query.html#hasMoreSolutions()"><CODE>hasMoreSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#nextSolution()"><CODE>nextSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#rewind()"><CODE>rewind()</CODE></A>, 
<A HREF="../jpl/Query.html#oneSolution()"><CODE>oneSolution()</CODE></A>, 
<A HREF="../jpl/Query.html#allSolutions()"><CODE>allSolutions()</CODE></A>, 
<A HREF="../jpl/Query.html#query()"><CODE>query()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="abort()"><!-- --></A><H3>
abort</H3>
<PRE>
public final int <B>abort</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns the String representation of a Query.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the String representation of a Query</DL>
</DD>
</DL>
<HR>

<A NAME="debugString()"><!-- --></A><H3>
debugString</H3>
<PRE>
public java.lang.String <B>debugString</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I></I>&nbsp;
<P>
<DD>Returns a debug-friendly representation of a Query
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>a debug-friendly representation of a Query</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Query.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../jpl/JVoid.html" title="class in jpl"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../jpl/Term.html" title="class in jpl"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Query.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
