<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<HTML>
<HEAD>
<TITLE>SWI-Prolog/XPCE Semantic Web Library</TITLE>
</HEAD>
<BODY BGCOLOR="white"> 
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE>
<CENTER>

<H1>SWI-Prolog/XPCE Semantic Web Library</H1>

</CENTER>
<HR>
<CENTER>
<I>Jan Wielemaker <BR>
SWI, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A HREF="mailto:jan@swi.psy.uva.nl">jan@swi.psy.uva.nl</A></I>
</CENTER>
<HR>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
</BLOCKQUOTE>
<CENTER><H3>Abstract</H3></Center>
<TABLE WIDTH="90%" ALIGN=center BORDER=2 BGCOLOR="#f0f0f0"><TR><TD>
This document describes a library for dealing with standards from the
<A HREF="http://www.w3c.org/">W3C</A> standard for the <EM>Semantic Web</EM>. 
Like the standards themselves (RDF, RDFS and OWL) this infrastructure is 
modular. It consists of Prolog packages for reading, querying and 
storing semantic web documents as well as XPCE libraries that provide 
visualisation and editing. The Prolog libraries can be used without the 
XPCE GUI modules. The library can handle upto about 2 million
<EM>RDF triples</EM> on current commonly used hardware (256MB memory, 
Pentium 1.5Ghz).
</TABLE>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<UL>
<LI><A HREF="#sec:1"><B>1 Introduction</B></A>
<LI><A HREF="#sec:2"><B>2 Modules</B></A>
<LI><A HREF="#sec:3"><B>3 Module rdf_db</B></A>
<UL>
<LI><A HREF="#sec:3.1">3.1 Query the RDF database</A>
<LI><A HREF="#sec:3.2">3.2 Predicate properties</A>
<LI><A HREF="#sec:3.3">3.3 Modifying the database</A>
<UL>
<LI><A HREF="#sec:3.3.1">3.3.1 Modifying predicates</A>
<LI><A HREF="#sec:3.3.2">3.3.2 Transactions</A>
</UL>
<LI><A HREF="#sec:3.4">3.4 Loading and saving to file</A>
<UL>
<LI><A HREF="#sec:3.4.1">3.4.1 Partial save</A>
<LI><A HREF="#sec:3.4.2">3.4.2 Fast loading and saving</A>
<LI><A HREF="#sec:3.4.3">3.4.3 MD5 digests</A>
</UL>
<LI><A HREF="#sec:3.5">3.5 Namespace Handling</A>
<LI><A HREF="#sec:3.6">3.6 Miscellaneous predicates</A>
<LI><A HREF="#sec:3.7">3.7 Issues with rdf_db</A>
</UL>
<LI><A HREF="#sec:4"><B>4 Module rdfs</B></A>
<UL>
<LI><A HREF="#sec:4.1">4.1 Hierarchy and class-individual relations</A>
<LI><A HREF="#sec:4.2">4.2 Collections and Containers</A>
<LI><A HREF="#sec:4.3">4.3 Labels and textual search</A>
</UL>
<LI><A HREF="#sec:5"><B>5 Module owl</B></A>
<LI><A HREF="#sec:6"><B>6 Module rdf_edit</B></A>
<UL>
<LI><A HREF="#sec:6.1">6.1 Transaction management</A>
<LI><A HREF="#sec:6.2">6.2 File management</A>
<LI><A HREF="#sec:6.3">6.3 Encapsulated predicates</A>
<LI><A HREF="#sec:6.4">6.4 High-level modification predicates</A>
<LI><A HREF="#sec:6.5">6.5 Undo</A>
<LI><A HREF="#sec:6.6">6.6 Journalling</A>
<LI><A HREF="#sec:6.7">6.7 Broadcasting change events</A>
</UL>
<LI><A HREF="#sec:7"><B>7 Related packages and issues</B></A>
</UL>

<H2><A NAME="sec:1">1 Introduction</A></H2>

<P>SWI-Prolog has started support for web-documents with the development 
of a small and fast SGML/XML parser, followed by an RDF parser (early 
2000). With the <CODE>semweb</CODE> library we provide more high level 
support for manipulating semantic web documents. The semantic web is the 
likely point of orientation for knowledge representation in the future, 
making a library designed in its spirit promising.

<H2><A NAME="sec:2">2 Modules</A></H2>

<P>Central to this library is the module <CODE>rdf_db.pl</CODE>, 
providing storage and basic querying for RDF triples. This triple store 
is filled using the RDF parser realised by <CODE>rdf.pl</CODE>. The 
storage module can quickly save and load (partial) databases. The 
modules <CODE>rdfs.pl</CODE> and <CODE>owl.pl</CODE> add querying in 
terms of the more powerful RDFS and OWL languages. Module <CODE>rdf_edit.pl</CODE> 
adds editing, undo, journaling and change-forwarding. Finally, a variety 
of XPCE modules visualise and edit the database. Figure <A HREF="#fig:modules">figure 
1</A> summarised the modular design.

<P><A NAME="fig:modules"></A>
<CENTER>
<IMG SRC="modules.gif">
</CENTER>

<P>
<TABLE ALIGN=center WIDTH="75%"><TR><TD>
<B>Figure 1 : </B>Modules for the Semantic Web library</TABLE>

<H2><A NAME="sec:3">3 Module rdf_db</A></H2>

<P>The central module is called <CODE>rdf_db</CODE>. It provides storage 
and indexed querying of RDF triples. Triples are stored as a quintuple. 
The first three elements denote the RDF triple. <VAR>File</VAR> and
<VAR>Line</VAR> provide information about the origin of the triple.
<BLOCKQUOTE>
{<VAR>Subject</VAR> <VAR>Predicate</VAR> <VAR>Object</VAR> <VAR>File</VAR> <VAR>Line</VAR>}
</BLOCKQUOTE>

<P>The actual storage is provided by the <EM>foreign language (C)</EM> 
module <CODE>rdf_db.c</CODE>. Using a dedicated C-based implementation 
we can reduced memory usage and improve indexing capabilities.<A NAME=back-to-note-1 HREF="semweb.html#note-1"> (1)</A> 
Currently the following indexing is provided.

<P>
<UL>
<LI>Any of the 3 fields of the triple
<LI><VAR>Subject</VAR> + <VAR>Predicate</VAR> and <VAR>Predicate</VAR> + <VAR>Object</VAR>
<LI><VAR>Predicates</VAR> are indexed on the <EM>highest property</EM>. 
In other words, if predicates are related through
<CODE>subPropertyOf</CODE> predicates indexing happens on the most 
abstract predicate. This makes calls to <A NAME="idx:rdfhas4:1"></A><A HREF="#rdf_has/4">rdf_has/4</A> 
very efficient.
<LI>String literal <VAR>Objects</VAR> are indexed case-insensitive to 
make case-insensitive queries fully indexed. See <A NAME="idx:rdf3:2"></A><A HREF="#rdf/3">rdf/3</A>.
</UL>

<H3><A NAME="sec:3.1">3.1 Query the RDF database</A></H3>

<DL>

<P>
<DT><A NAME="rdf/3"><STRONG>rdf</STRONG>(<VAR>?Subject, ?Predicate, 
?Object</VAR>)</A><DD>
Elementary query for triples. <VAR>Subject</VAR> and <VAR>Predicate</VAR> 
are atoms representing the fully qualified URL of the resource. <VAR>Object</VAR> 
is either an atom representing a resource or <CODE>literal(Value)</CODE> 
if the object is a literal value. If a value of the form
<CODE>NameSpaceID : LocalName</CODE> is provided it is expanded to a 
ground atom using <A NAME="idx:expandgoal2:3"></A><B>expand_goal/2</B>. 
This implies you can use this construct in compiled code without paying 
a preformance penalty. See also
<A HREF="#sec:rdfns">section 3.5</A>. Literal values take one of the 
following forms:

<DL>

<P>
<DT><STRONG>Atom</STRONG><DD>
If the value is a simple atom it is the textual representation of a 
string literal without explicit type or language (<CODE>xml:lang</CODE>) 
qualifier.

<P>
<DT><STRONG>lang</STRONG>(<VAR>LangID, Atom</VAR>)<DD>
<VAR>Atom</VAR> represents the text of a string literal qualified with 
the given language.

<P>
<DT><STRONG>type</STRONG>(<VAR>TypeID, Value</VAR>)<DD>
Used for attributes qualified using the <CODE>rdf:dataType</CODE>
<VAR>TypeID</VAR>. The <VAR>Value</VAR> is either the textual 
representation or a natural Prolog representation. See the option
<CODE>convert_typed_literal(:Convertor)</CODE> of the parser. The 
storage layer provides efficient handling of atoms, integers and floats. 
All other data is represented as a Prolog record.
</DL>

<P>For string querying purposes, <VAR>Object</VAR> can be of the form
<CODE>literal(+Query, -Value)</CODE>, where <VAR>Query</VAR> is one of

<DL>

<P>
<DT><STRONG>exact</STRONG>(<VAR>+Text</VAR>)<DD>
Perform exact, but case-insensitive match. This query is fully indexed.

<P>
<DT><STRONG>substring</STRONG>(<VAR>+Text</VAR>)<DD>
Match any literal that contains <VAR>Text</VAR> as a case-insensitive 
substring. The query is not indexed on <VAR>Object</VAR>.

<P>
<DT><STRONG>word</STRONG>(<VAR>+Text</VAR>)<DD>
Match any literal that contains <VAR>Text</VAR> delimited by a non 
alpha-numeric character, the start or end of the string. The query is 
not indexed on <VAR>Object</VAR>.

<P>
<DT><STRONG>prefix</STRONG>(<VAR>+Text</VAR>)<DD>
Match any literal that starts with <VAR>Text</VAR>. This call is 
intended for <EM>completion</EM>. The query is not indexed on <VAR>Object</VAR>.

<P>
<DT><STRONG>like</STRONG>(<VAR>+Pattern</VAR>)<DD>
Match any literal that matches <VAR>Pattern</VAR> case insensitively, 
where the `*' character in <VAR>Pattern</VAR> matches zero or more 
characters.
</DL>

<P>Backtracking never returns duplicate triples. Duplicates can be 
retrieved using <A NAME="idx:rdf4:4"></A><A HREF="#rdf/4">rdf/4</A>.

<P>
<DT><A NAME="rdf/4"><STRONG>rdf</STRONG>(<VAR>?Subject, ?Predicate, 
?Object, ?Source</VAR>)</A><DD>
As <A NAME="idx:rdf3:5"></A><A HREF="#rdf/3">rdf/3</A> but in addition 
return the source-location of the triple. The source is either a plain 
atom or a term of the format
<CODE>Atom : Integer</CODE> where <VAR>Atom</VAR> is intended to be used 
as filename or URL and <VAR>Integer</VAR> for representing the 
line-number. Unlike <A NAME="idx:rdf3:6"></A><A HREF="#rdf/3">rdf/3</A>, 
this predicate does not remove duplicates from the result set.

<P>
<DT><A NAME="rdf_has/4"><STRONG>rdf_has</STRONG>(<VAR>?Subject, 
?Predicate, ?Object, -TriplePred</VAR>)</A><DD>
This query exploits the RDFS <CODE>subPropertyOf</CODE> relation. It 
returns any triple whose stored predicate equals <VAR>Predicate</VAR> or 
can reach this by following the recursive <VAR>subPropertyOf</VAR> 
relation. The actual stored predicate is returned in <VAR>TriplePred</VAR>. 
The example below gets all subclasses of an RDFS (or OWL) class, even if 
the relation used is not <CODE>rdfs:subClassOf</CODE>, but a 
user-defined sub-property thereof.<A NAME=back-to-note-2 HREF="semweb.html#note-2"> (2)</A>

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

subclasses(Class, SubClasses) :-
        findall(S, rdf_has(S, rdfs:subClassOf, Class), SubClasses).
</PRE>
</TABLE>

<P>Note that <A NAME="idx:rdfhas4:7"></A><A HREF="#rdf_has/4">rdf_has/4</A> 
and <A NAME="idx:rdfhas3:8"></A><A HREF="#rdf_has/3">rdf_has/3</A> can 
return duplicate answers if they use a different <VAR>TriplePred</VAR>.

<P>
<DT><A NAME="rdf_has/3"><STRONG>rdf_has</STRONG>(<VAR>?Subject, 
?Predicate, ?Object</VAR>)</A><DD>
Same as <CODE>rdf_has(Subject, Predicate, Object, _)</CODE>.

<P>
<DT><A NAME="rdf_reachable/3"><STRONG>rdf_reachable</STRONG>(<VAR>?Subject, 
+Predicate, ?Object</VAR>)</A><DD>
Is true if <VAR>Object</VAR> can be reached from <VAR>Subject</VAR> 
following the transitive predicate <VAR>Predicate</VAR> or a 
sub-property thereof. When used with either <VAR>Subject</VAR> or <VAR>Object</VAR> 
unbound, it first returns the origin, followed by the reachable nodes in 
breath-first search-order. It never generates the same node twice and is 
robust against cycles in the transitive relation. With all arguments 
instantiated it succeeds deterministically of the relation if a path can 
be found from <VAR>Subject</VAR> to <VAR>Object</VAR>. Searching starts 
at <VAR>Subject</VAR>, assuming the branching factor is normally lower. 
A call with both <VAR>Subject</VAR> and <VAR>Object</VAR> unbound raises 
an instantiation error. The following example generates all subclasses 
of <CODE>rdfs:Resource</CODE>:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

?- rdf_reachable(X, rdfs:subClassOf, rdfs:'Resource').

X = 'http://www.w3.org/2000/01/rdf-schema#Resource' ;

X = 'http://www.w3.org/2000/01/rdf-schema#Class' ;

X = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property' ;

...
</PRE>
</TABLE>

<P>
<DT><A NAME="rdf_subject/1"><STRONG>rdf_subject</STRONG>(<VAR>?Subject</VAR>)</A><DD>
Enumerate resources appearing as a subject in a triple. The main reason 
for this predicate is to generate the known subjects <EM>without 
duplicates</EM> as one gets using <CODE>rdf(Subject, _, _)</CODE>.
</DL>

<H3><A NAME="sec:3.2">3.2 Predicate properties</A></H3>

<A NAME="sec:predproperty"></A>

<P>The predicates below form an experimental interface to provide more 
reasoning inside the kernel of the rdb_db engine. Note that
<CODE>symetric</CODE>, <CODE>inverse_of</CODE> and <CODE>transitive</CODE> 
are not yet supported by the rest of the engine.

<DL>

<P>
<DT><A NAME="rdf_set_predicate/2"><STRONG>rdf_set_predicate</STRONG>(<VAR>+Predicate, 
+Property</VAR>)</A><DD>
Define a property of the predicate. Defined properties are listed with <A NAME="idx:rdfpredicateproperty2:9"></A><A HREF="#rdf_predicate_property/2">rdf_predicate_property/2</A>.

<P>
<DT><A NAME="rdf_predicate_property/2"><STRONG>rdf_predicate_property</STRONG>(<VAR>+Predicate, 
-Property</VAR>)</A><DD>
Query properties of a defined predicate. Currently defined properties 
are given below.

<DL>

<P>
<DT><STRONG>symmetric</STRONG>(<VAR>Bool</VAR>)<DD>
True if the predicate is defined to be symetric. I.e. 
{A} P {B} implies {B} P {A}.

<P>
<DT><STRONG>inverse_of</STRONG>(<VAR>Inverse</VAR>)<DD>
True if this predicate is the inverse of <VAR>Inverse</VAR>.

<P>
<DT><STRONG>transitive</STRONG>(<VAR>Bool</VAR>)<DD>
True if this predicate is transitive.

<P>
<DT><STRONG>triples</STRONG>(<VAR>Triples</VAR>)<DD>
Unify <VAR>Triples</VAR> with the number of existing triples using this 
predicate as second argument. Reporting the number of triples is 
intended to support query optimization.

<P>
<DT><STRONG>rdf_subject_branch_factor</STRONG>(<VAR>-Float</VAR>)<DD>
Unify <VAR>Float</VAR> with the average number of triples associated 
with each unique value for the subject-side of this relation. If there 
are no triples the value 0.0 is returned. This value is cached with the 
predicate and recomputed only after substantial changes to the triple 
set associated to this relation. This property is indented for path 
optimalisation when solving conjunctions of <A NAME="idx:rdf3:10"></A><A HREF="#rdf/3">rdf/3</A> 
goals.

<P>
<DT><STRONG>rdf_object_branch_factor</STRONG>(<VAR>-Float</VAR>)<DD>
Unify <VAR>Float</VAR> with the average number of triples associated 
with each unique value for the object-side of this relation. In addition 
to the comments with the subject_branch_factor property, uniqueness of 
the object value is computed from the hash key rather than the actual 
values.

<P>
<DT><STRONG>rdfs_subject_branch_factor</STRONG>(<VAR>-Float</VAR>)<DD>
Same as rdf_subject_branch_factor/1 , but also considering triples of 
`subPropertyOf' this relation. See also <A NAME="idx:rdfhas3:11"></A><A HREF="#rdf_has/3">rdf_has/3</A>.

<P>
<DT><STRONG>rdfs_object_branch_factor</STRONG>(<VAR>-Float</VAR>)<DD>
Same as rdf_object_branch_factor/1 , but also considering triples of 
`subPropertyOf' this relation. See also <A NAME="idx:rdfhas3:12"></A><A HREF="#rdf_has/3">rdf_has/3</A>.
</DL>

</DL>

<H3><A NAME="sec:3.3">3.3 Modifying the database</A></H3>

<A NAME="sec:rdfmodify"></A>

<P>As depicted in <A HREF="#fig:modules">figure 1</A>, there are two 
levels of modification. The <CODE>rdf_db</CODE> module simply modifies, 
where the <CODE>rdf_edit</CODE> library provides transactions and undo 
on top of this. Applications that wish to use the <CODE>rdf_edit</CODE> 
layer must <EM>never</EM> use the predicates from this section directly.

<H4><A NAME="sec:3.3.1">3.3.1 Modifying predicates</A></H4>

<A NAME="sec:modpreds"></A>

<DL>

<P>
<DT><A NAME="rdf_assert/3"><STRONG>rdf_assert</STRONG>(<VAR>+Subject, 
+Predicate, +Object</VAR>)</A><DD>
Assert a new triple into the database. This is equivalent to
<A NAME="idx:rdfassert4:13"></A><A HREF="#rdf_assert/4">rdf_assert/4</A> 
using <VAR>SourceRef</VAR> <CODE>user</CODE>. <VAR>Subject</VAR> and
<VAR>Predicate</VAR> are resources. <VAR>Object</VAR> is either a 
resource or a term <CODE>literal(Value)</CODE>. See <A NAME="idx:rdf3:14"></A><A HREF="#rdf/3">rdf/3</A> 
for an explanation of <VAR>Value</VAR> for typed and language qualified 
literals. All arguments are subject to name-space expansion (see <A HREF="#sec:rdfns">section 
3.5</A>).

<P>
<DT><A NAME="rdf_assert/4"><STRONG>rdf_assert</STRONG>(<VAR>+Subject, 
+Predicate, +Object, +SourceRef</VAR>)</A><DD>
As <A NAME="idx:rdfassert3:15"></A><A HREF="#rdf_assert/3">rdf_assert/3</A>, 
adding <VAR>SourceRef</VAR> to specify the orgin of the triple. <VAR>SourceRef</VAR> 
is either an atom or a term of the format
<VAR>Atom</VAR>:<VAR>Int</VAR> where <VAR>Atom</VAR> normally refers to 
a filename and <VAR>Int</VAR> to the line-number where the description 
starts.

<P>
<DT><A NAME="rdf_retractall/3"><STRONG>rdf_retractall</STRONG>(<VAR>?Subject, 
?Predicate, ?Object</VAR>)</A><DD>
Removes all matching triples from the database. Previous Prolog 
implementations also provided a backtracking <B>rdf_retract/3</B>, but 
this proved to be rarely used and could always be replaced with
<A NAME="idx:rdfretractall3:16"></A><A HREF="#rdf_retractall/3">rdf_retractall/3</A>. 
As <A NAME="idx:rdfretractall4:17"></A><A HREF="#rdf_retractall/4">rdf_retractall/4</A> 
using an unbound <VAR>SourceRef</VAR>.

<P>
<DT><A NAME="rdf_retractall/4"><STRONG>rdf_retractall</STRONG>(<VAR>?Subject, 
?Predicate, ?Object, ?SourceRef</VAR>)</A><DD>
As <A NAME="idx:rdfretractall4:18"></A><A HREF="#rdf_retractall/4">rdf_retractall/4</A>, 
also matching on the <VAR>SourceRef</VAR>. This is particulary useful to 
update all triples coming from a loaded file.

<P>
<DT><A NAME="rdf_update/4"><STRONG>rdf_update</STRONG>(<VAR>+Subject, 
+Predicate, +Object, +Action</VAR>)</A><DD>
Replaces one of the three fields on the matching triples depending on <VAR>Action</VAR>:

<DL>

<P>
<DT><STRONG>subject</STRONG>(<VAR>Resource</VAR>)<DD>
Changes the first field of the triple.

<P>
<DT><STRONG>predicate</STRONG>(<VAR>Resource</VAR>)<DD>
Changes the second field of the triple.

<P>
<DT><STRONG>object</STRONG>(<VAR>Object</VAR>)<DD>
Changes the last field of the triple to the given resource or
<CODE>literal(Value)</CODE>.

<P>
<DT><STRONG>source</STRONG>(<VAR>Source</VAR>)<DD>
Changes the source location (<EM>payload</EM>). Note that updating the 
source has no consequences for the semantics and therefore the
<EM>generation</EM> (see <A NAME="idx:rdfgeneration1:19"></A><A HREF="#rdf_generation/1">rdf_generation/1</A>) 
is <EM>not</EM> updated.
</DL>

<P>
<DT><A NAME="rdf_update/5"><STRONG>rdf_update</STRONG>(<VAR>+Subject, 
+Predicate, +Object, +Source,+Action</VAR>)</A><DD>
As <A NAME="idx:rdfupdate4:20"></A><A HREF="#rdf_update/4">rdf_update/4</A> 
but allows for specifying the source.

<P>
</DL>

<H4><A NAME="sec:3.3.2">3.3.2 Transactions</A></H4>

<A NAME="transactions"></A>

<P><A NAME="idx:transaction:21"></A>The predicates from <A HREF="#sec:modpreds">section 
3.3.1</A> perform immediate and atomic modifications to the database. 
There are two cases where this is not desirable:

<P><OL>
<LI>If the database is modified using information based on reading the 
same database. A typical case is a forward reasoner examining the 
database and asserting new triples that can be deduced from the already 
existing ones. For example, <EM>if length(X) &gt; 2 then size(X) is 
large</EM>:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

        (   rdf(X, length, literal(L)),
            atom_number(L, IL),
            IL &gt; 2,
            rdf_assert(X, size, large),
            fail
        ;   true
        ).
</PRE>
</TABLE>

<P>Running this code without precautions causes an error because
<A NAME="idx:rdfassert3:22"></A><A HREF="#rdf_assert/3">rdf_assert/3</A> 
tries to get a write lock on the database which has an a read operation 
(rdf/3 has choicepoints) in progress.

<P>
<LI>Multi-threaded access making multiple changes to the database that 
must be handled as a unit.
</OL>

<P>Where the second case is probably obvious, the first case is less so. 
The storage layer may require reindexing after adding or deleting 
triples. Such reindexing operatations however are not possible while 
there are active read operations in other threads or from choicepoints 
that can be in the same thread. For this reason we added
<A NAME="idx:rdftransaction1:23"></A><A HREF="#rdf_transaction/1">rdf_transaction/1</A>. 
Note that, like the predicates from
<A HREF="#sec:modpreds">section 3.3.1</A>, <A NAME="idx:rdftransaction1:24"></A><A HREF="#rdf_transaction/1">rdf_transaction/1</A> 
raises a permission error exception if the calling thread has active 
choicepoints on the database. The problem is illustrated below. The <A NAME="idx:rdf3:25"></A><A HREF="#rdf/3">rdf/3</A> 
call leaves a choicepoint and as the read lock originates from the 
calling thread itself the system will deadlock if it would not generate 
an exception.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

1 ?- rdf_assert(a,b,c).
 
Yes
2 ?- rdf_assert(a,b,d).
 
Yes
3 ?- rdf(a,b,X), rdf_transaction(rdf_assert(a,b,e)).
ERROR: No permission to write rdf_db `default' (Operation would deadlock)
^  Exception: (8) rdf_db:rdf_transaction(rdf_assert(a, b, e)) ? no debug
4 ?-
</PRE>
</TABLE>

<DL>

<P>
<DT><A NAME="rdf_transaction/1"><STRONG>rdf_transaction</STRONG>(<VAR>:Goal</VAR>)</A><DD>
After starting a transaction, all predicates from <A HREF="#sec:modpreds">section 
3.3.1</A> append their operation to the <EM>transaction</EM> instead of 
modifying the database. If <VAR>Goal</VAR> succeeds rdf_transaction cuts 
all choicepoints in <VAR>Goal</VAR> and executes all recorded 
operations. If
<VAR>Goal</VAR> fails or throws an exception, all recorded operations 
are discarded and <A NAME="idx:rdftransaction1:26"></A><A HREF="#rdf_transaction/1">rdf_transaction/1</A> 
fails or re-throws the exception.

<P>On entry, <A NAME="idx:rdftransaction1:27"></A><A HREF="#rdf_transaction/1">rdf_transaction/1</A> 
gains exclusive access to the database, but does allow readers to come 
in from all threads. After the successful completion of <VAR>Goal</VAR> <A NAME="idx:rdftransaction1:28"></A><A HREF="#rdf_transaction/1">rdf_transaction/1</A> 
gains completely exclusive access while performing the database updates.

<P>Transactions may be nested. Committing a nested transactions merges 
its change records into the outer transaction, while discarding a nested 
transaction simply destroys the change records belonging to the nested 
transaction.
</DL>

<H3><A NAME="sec:3.4">3.4 Loading and saving to file</A></H3>

<A NAME="sec:rdffile"></A>

<P>The <CODE>rdf_db</CODE> module can read and write RDF-XML for import 
and export as well as a binary format built for quick load and save 
described in <A HREF="#sec:rdffastfile">section 3.4.2</A>. Here are the 
predicates for portable RDF load and save.

<DL>

<P>
<DT><A NAME="rdf_load/1"><STRONG>rdf_load</STRONG>(<VAR>+In</VAR>)</A><DD>
Load triples from <VAR>In</VAR>, which is either a stream opened for 
reading or an atom specifying a filename. This predicate calls
<A NAME="idx:processrdf3:29"></A><B>process_rdf/3</B> to read the source 
one description at a time, avoiding limits to the size of the input. If <VAR>In</VAR> 
is a file, <A NAME="idx:rdfload1:30"></A><A HREF="#rdf_load/1">rdf_load/1</A> 
provides for caching the results for quick-load using <A NAME="idx:rdfloaddb1:31"></A><A HREF="#rdf_load_db/1">rdf_load_db/1</A> 
described below. Caching is activated by creating a directory
<CODE>.cache</CODE> (or <CODE>_cache</CODE> on Windows) in the directory 
holding the <CODE>.rdf</CODE> files. Cached RDF files are loaded at 
approx. 25 times the speed of RDF-XML files.

<P>
<DT><A NAME="rdf_load/2"><STRONG>rdf_load</STRONG>(<VAR>+File, +Options</VAR>)</A><DD>
As <A NAME="idx:rdfload1:32"></A><A HREF="#rdf_load/1">rdf_load/1</A>, 
providing additional options. The options are handed to the RDF parser 
as implemented by <A NAME="idx:processrdf3:33"></A><B>process_rdf/3</B>.

<P>
<DT><A NAME="rdf_unload/1"><STRONG>rdf_unload</STRONG>(<VAR>+Spec</VAR>)</A><DD>
Remove all triples loaded from <VAR>Spec</VAR>. In the current 
implementation
<VAR>Spec</VAR> must refer to a file.

<P>
<DT><A NAME="rdf_save/1"><STRONG>rdf_save</STRONG>(<VAR>+File</VAR>)</A><DD>
Save all known triples to the given <VAR>File</VAR>. Same as
<CODE>rdf_save(File,)</CODE>.

<P>
<DT><A NAME="rdf_save/2"><STRONG>rdf_save</STRONG>(<VAR>+File, +Options</VAR>)</A><DD>
Save with options. Provided options are:

<DL>

<P>
<DT><STRONG>db</STRONG>(<VAR>+FileRef</VAR>)<DD>
Save all triples whose file-part of their <VAR>SourceRef</VAR> matches
<VAR>FileRef</VAR> to the given <VAR>File</VAR>. Saving arbitrary 
selections is possible using predicates from <A HREF="#sec:partsave">section 
3.4.1</A>.

<P>
<DT><STRONG>anon</STRONG>(<VAR>+Bool</VAR>)<DD>
if <CODE>anon(false)</CODE> is provided anonymous resources are only 
saved if the resource appears in the object field of another triple that 
is saved.

<P>
<DT><STRONG>convert_typed_literal</STRONG>(<VAR>:Converter</VAR>)<DD>
If present, raw literal values are first passed to <VAR>Converter</VAR> 
to apply the reverse of the <CODE>convert_typed_literal</CODE> option of 
the RDF parser. The <VAR>Converter</VAR> is called with the same 
arguments as in the RDF parser, but now with the last argument 
instantiated and the first two unbound. A proper convertor that can be 
used for both loading and saving must be a logical predicate.
</DL>

<P>
<DT><A NAME="rdf_source/1"><STRONG>rdf_source</STRONG>(<VAR>?File</VAR>)</A><DD>
Test or enumerate the files loaded using <A NAME="idx:rdfload1:34"></A><A HREF="#rdf_load/1">rdf_load/1</A>.

<P>
<DT><A NAME="rdf_make/0"><STRONG>rdf_make</STRONG></A><DD>
Re-load all RDF sourcefiles (see <A NAME="idx:rdfsource1:35"></A><A HREF="#rdf_source/1">rdf_source/1</A>) 
that have changed since they were loaded the last time. This implies all 
triples that originate from the file are removed and the file is 
re-loaded. If the file is cached a new cache-file is written. Please 
note that the new triples are added at the end of the database, possibly 
changing the order of (conflicting) triples.
</DL>

<H4><A NAME="sec:3.4.1">3.4.1 Partial save</A></H4>

<A NAME="sec:partsave"></A>

<P>Sometimes it is necessary to make more arbitrary selections of 
material to be saved or exchange RDF descriptions over an open network 
link. The predicates in this section provide for this.

<DL>

<P>
<DT><A NAME="rdf_save_header/2"><STRONG>rdf_save_header</STRONG>(<VAR>+Stream, 
+Options</VAR>)</A><DD>
Save an RDF header, with the XML header, <CODE>DOCTYPE</CODE>,
<CODE>ENTITY</CODE> and opening the <CODE>rdf:RDF</CODE> element with 
appropriate namespace declarations. It uses the primitives from <A HREF="#sec:rdfns">section 
3.5</A> to generate the required namespaces and desired short-name. <VAR>Options</VAR> 
is one of:

<DL>

<P>
<DT><STRONG>db</STRONG>(<VAR>+FileRef</VAR>)<DD>
Only search for namespaces used in triples labeled with
<VAR>FileRef</VAR>.
</DL>

<P>
<DT><A NAME="rdf_save_footer/1"><STRONG>rdf_save_footer</STRONG>(<VAR>+Stream</VAR>)</A><DD>
Close the work opened with <A NAME="idx:rdfsaveheader2:36"></A><A HREF="#rdf_save_header/2">rdf_save_header/2</A>.

<P>
<DT><A NAME="rdf_save_subject/3"><STRONG>rdf_save_subject</STRONG>(<VAR>+Stream, 
+Subject, +FileRef</VAR>)</A><DD>
Save everything known about <VAR>Subject</VAR> that matches <VAR>FileRef</VAR>. 
Using an variable for <VAR>FileRef</VAR> saves all triples with
<VAR>Subject</VAR>.
</DL>

<H4><A NAME="sec:3.4.2">3.4.2 Fast loading and saving</A></H4>

<A NAME="sec:rdffastfile"></A>

<P>Loading and saving RDF format is relatively slow. For this reason we 
designed a binary format that is more compact, avoids the complications 
of the RDF parser and avoids repetitive lookup of (URL) identifiers. 
Especially the speed improvement of about 25 times is worth-while when 
loading large databases. These predicates are used for caching by
<A NAME="idx:rdfload12:37"></A><A HREF="#rdf_load/1">rdf_load/[1,2]</A> 
under certain conditions.

<DL>

<P>
<DT><A NAME="rdf_save_db/1"><STRONG>rdf_save_db</STRONG>(<VAR>+File</VAR>)</A><DD>
Save all known triples into <VAR>File</VAR>. The saved version includes 
the
<VAR>SourceRef</VAR> information.

<P>
<DT><A NAME="rdf_save_db/1"><STRONG>rdf_save_db</STRONG>(<VAR>+File, 
+FileRef</VAR>)</A><DD>
Save all triples with <VAR>SourceRef</VAR> <VAR>FileRef</VAR>, 
regardless of the line-number. For example, using <CODE>user</CODE> all 
information added using <A NAME="idx:rdfassert3:38"></A><A HREF="#rdf_assert/3">rdf_assert/3</A> 
is stored in the database.

<P>
<DT><A NAME="rdf_load_db/1"><STRONG>rdf_load_db</STRONG>(<VAR>+File</VAR>)</A><DD>
Load triples from <VAR>File</VAR>.
</DL>

<H4><A NAME="sec:3.4.3">3.4.3 MD5 digests</A></H4>

<P>The <CODE>rdf_db</CODE> library provides for <EM>MD5 digests</EM>. An 
MD5 digest is a 128 bit long hash key computed from the triples based on 
the RFC-1321 standard. MD5 keys are computed for each individual triple 
and added together to compute the final key, resulting in a key that 
describes the triple-set but is independant from the order in which the 
triples appear. It is claimed that it is practically impossible for two 
different datasets to generate the same MD5 key. The Triple20 editor 
uses the MD5 key for detecting whether the triples associated to a file 
have changed as well as to maintain a directory with snapshots of 
versioned ontology files.

<DL>

<P>
<DT><A NAME="rdf_md5/2"><STRONG>rdf_md5</STRONG>(<VAR>+Source, -MD5</VAR>)</A><DD>
Return the MD5 digest for all triples in the database associated to
<VAR>Source</VAR>. The <VAR>MD5</VAR> digest itself is represented as an 
atom holding a 32-character hexadecimal string. The library maintains 
the digest incrementally on <A NAME="idx:rdfload12:39"></A><A HREF="#rdf_load/1">rdf_load/[1,2]</A>, <A NAME="idx:rdfloaddb1:40"></A><A HREF="#rdf_load_db/1">rdf_load_db/1</A>, <A NAME="idx:rdfassert34:41"></A><A HREF="#rdf_assert/3">rdf_assert/[3,4]</A> 
and <A NAME="idx:rdfretractall34:42"></A><A HREF="#rdf_retractall/3">rdf_retractall/[3,4]</A>. 
Checking whether the digest has changed since the last <A NAME="idx:rdfload12:43"></A><A HREF="#rdf_load/1">rdf_load/[1,2]</A> 
call provides a practical means for checking whether the file needs to 
be saved.

<P>
<DT><A NAME="rdf_atom_md5/3"><STRONG>rdf_atom_md5</STRONG>(<VAR>+Text, 
+Times, -MD5</VAR>)</A><DD>
Computes the MD5 hash from <VAR>Text</VAR>, which is an atom, string or 
list of character codes. <VAR>Times</VAR> is an integer <VAR>&gt;= 1</VAR>. 
When
<VAR>&gt; 0</VAR>, the MD5 algorithm is repeated <VAR>Times</VAR> times 
on the generated hash. This can be used for password encryption 
algorithms to make generate-and-test loops slow.

<P>This predicate bears little relation to RDF handling. It is provided 
because the RDF library already contains the MD5 algorithm and semantic 
web services may involve security and consistency checking. This 
predicate provides a platform independant alternative to the
<CODE>library(crypt)</CODE> library provided with the <TT>clib</TT> 
package.
</DL>

<H3><A NAME="sec:3.5">3.5 Namespace Handling</A></H3>

<A NAME="sec:rdfns"></A>

<P>Prolog code often contains references to constant resources in a 
known XML namespace. For example,
<CODE>http://www.w3.org/2000/01/rdf-schema#Class</CODE> refers to the 
most general notion of a class. Readability and maintability concerns 
require for abstraction here. The dynamic and multifile predicate 
rdf_db:ns/2 maintains a mapping between short meaningful names and 
namespace locations very much like the XML <CODE>xmlns</CODE> construct. 
The initial mapping contains the namespaces required for the semantic 
web languages themselves:

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

ns(rdf,  'http://www.w3.org/1999/02/22-rdf-syntax-ns#').
ns(rdfs, 'http://www.w3.org/2000/01/rdf-schema#').
ns(owl,  'http://www.w3.org/2002/7/owl#').
ns(xsd,  'http://www.w3.org/2000/10/XMLSchema#').
ns(dc,   'http://purl.org/dc/elements/1.1/').
ns(eor,  'http://dublincore.org/2000/03/13/eor#').
</PRE>
</TABLE>

<P>All predicates for the semweb libraries use <A NAME="idx:goalexpansion2:44"></A><B>goal_expansion/2</B> 
rules to make the SWI-Prolog compiler rewrite terms of the form
<CODE>Id : Local</CODE> into the fully qualified URL. In addition, the 
following predicates are supplied:

<DL>

<P>
<DT><A NAME="rdf_equal/2"><STRONG>rdf_equal</STRONG>(<VAR>Resource1, 
Resource2</VAR>)</A><DD>
Defined as <CODE>Resource1 = Resource2</CODE>. As this predicate is 
subject to goal-expansion it can be used to obtain or test global URL 
values to readable values. The following goal unifies <VAR>X</VAR> with
<CODE>http://www.w3.org/2000/01/rdf-schema#Class</CODE> without more 
runtime overhead than normal Prolog unification.

<P><P><TABLE WIDTH="90%" ALIGN=center BORDER=6 BGCOLOR="#e0e0e0"><TR><TD NOWRAP>
<PRE>

        rdf_equal(rdfs:'Class', X)
</PRE>
</TABLE>

<P>
<DT><A NAME="rdf_register_ns/2"><STRONG>rdf_register_ns</STRONG>(<VAR>+Alias, 
+URL</VAR>)</A><DD>
Register <VAR>Alias</VAR> as a shorthand for <VAR>URL</VAR>. Note that 
the registration must be done before loading any files using them as 
namespace aliases are handled at compiletime through <A NAME="idx:goalexpansion2:45"></A><B>goal_expansion/2</B>.

<P>
<DT><A NAME="rdf_global_id/2"><STRONG>rdf_global_id</STRONG>(<VAR>?Alias:Local, 
?Global</VAR>)</A><DD>
Runtime translation between <VAR>Alias</VAR> and <VAR>Local</VAR> and a
<VAR>Global</VAR> URL. Expansion is normally done at compiletime. This 
predicate is often used to turn a global URL into a more readable term.

<P>
<DT><A NAME="rdf_global_object/2"><STRONG>rdf_global_object</STRONG>(<VAR>?Object, 
?NameExpandedObject</VAR>)</A><DD>
As <A NAME="idx:rdfglobalid2:46"></A><A HREF="#rdf_global_id/2">rdf_global_id/2</A>, 
but also expands the type field if the object is of the form <CODE>literal(<CODE>type(Type, 
Value)</CODE>)</CODE>. This predicate is used for goal expansion of the 
object fields in <A NAME="idx:rdf3:47"></A><A HREF="#rdf/3">rdf/3</A> 
and similar goals.

<P>
<DT><A NAME="rdf_global_term/2"><STRONG>rdf_global_term</STRONG>(<VAR>+Term0, 
-Term</VAR>)</A><DD>
Expands all <VAR>Alias</VAR>:<VAR>Local</VAR> in <VAR>Term0</VAR> and 
return the result in <VAR>Term</VAR>. Use infrequently for runtime 
expansion of namespace identifiers.

<P>
<DT><A NAME="rdf_split_url/3"><STRONG>rdf_split_url</STRONG>(<VAR>?Base, 
?Local, ?URL</VAR>)</A><DD>
Split a URL into a prefix and local part if used in mode -,-,+ or simply 
behave as <A NAME="idx:atomconcat3:48"></A><B>atom_concat/3</B> in other 
modes. The <VAR>URL</VAR> is split on the last <CODE>#</CODE> or <CODE>/</CODE> 
character.
</DL>

<H3><A NAME="sec:3.6">3.6 Miscellaneous predicates</A></H3>

<P>This section describes the remaining predicates of the <CODE>rdf_db</CODE> 
module.

<DL>

<P>
<DT><A NAME="rdf_node/1"><STRONG>rdf_node</STRONG>(<VAR>-Id</VAR>)</A><DD>
Generate a unique reference. The returned atom is guaranteed not to 
occur in the current database in any field of any triple.

<P>
<DT><A NAME="rdf_bnode/1"><STRONG>rdf_bnode</STRONG>(<VAR>-Id</VAR>)</A><DD>
Generate a unique blank node reference. The returned atom is guaranteed 
not to occur in the current database in any field of any triple and 
starts with '__bnode'.

<P>
<DT><A NAME="rdf_is_bnode/1"><STRONG>rdf_is_bnode</STRONG>(<VAR>+Id</VAR>)</A><DD>
Succeeds if <VAR>Id</VAR> is a blank node identifier (also called
<EM>anonymous resource</EM>). In the current implementation this implies 
it is an atom starting with a double underscore.

<P>
<DT><A NAME="rdf_source_location/2"><STRONG>rdf_source_location</STRONG>(<VAR>+Subject, 
-SourceRef</VAR>)</A><DD>
Return the source-location as <VAR>File</VAR>:<VAR>Line</VAR> of the 
first triple that is about <VAR>Subject</VAR>.

<P>
<DT><A NAME="rdf_generation/1"><STRONG>rdf_generation</STRONG>(<VAR>-Generation</VAR>)</A><DD>
Returns the <VAR>Generation</VAR> of the database. Each modification to 
the database increments the generation. It can be used to check the 
validity of cached results deduced from the database. Modifications 
changing multiple triples increment <VAR>Generation</VAR> with the 
number of triples modified, providing a heuristic for `how dirty' cached 
results may be.

<P>
<DT><A NAME="rdf_estimate_complexity/?Subject, ?Predicate, ?Object, -Complexity"><STRONG>rdf_estimate_complexity</STRONG>(<VAR>?Subject, 
?Predicate, ?Object, -Complexity</VAR>)</A><DD>
eturn the number of alternatives as indicated by the database internal 
hashed indexing. This is a rough measure for the number of alternatives 
we can expect for an <A NAME="idx:rdfhas3:49"></A><A HREF="#rdf_has/3">rdf_has/3</A> 
call using the given three arguments. When called with three variables, 
the total number of triples is returned. This estimate is used in query 
optimisation. See also <A NAME="idx:rdfpredicateproperty2:50"></A><A HREF="#rdf_predicate_property/2">rdf_predicate_property/2</A> 
and <A NAME="idx:rdfstatistics1:51"></A><A HREF="#rdf_statistics/1">rdf_statistics/1</A> 
for additional information to help optimisers.

<P>
<DT><A NAME="rdf_statistics/1"><STRONG>rdf_statistics</STRONG>(<VAR>?Statistics</VAR>)</A><DD>
Report statistics collected by the <CODE>rdf_db</CODE> module. Defined 
values for <VAR>Statistics</VAR> are:

<DL>

<P>
<DT><STRONG>lookup</STRONG>(<VAR>?Index, -Count</VAR>)<DD>
Number of lookups using a pattern of instantiated fields. <VAR>Index</VAR> 
is a term <CODE>rdf(S,P,O)</CODE>, where <VAR>S</VAR>, <VAR>P</VAR> and <VAR>O</VAR> 
are either <CODE>+</CODE> or <CODE>-</CODE>. For example <CODE>rdf(+,+,-)</CODE> 
returns the lookups with subject and predicate specified and object 
unbound.

<P>
<DT><STRONG>properties</STRONG>(<VAR>-Count</VAR>)<DD>
Number of unique values for the second field of the triple set.

<P>
<DT><STRONG>sources</STRONG>(<VAR>-Count</VAR>)<DD>
Number of files loaded through <A NAME="idx:rdfload1:52"></A><A HREF="#rdf_load/1">rdf_load/1</A>.

<P>
<DT><STRONG>subjects</STRONG>(<VAR>-Count</VAR>)<DD>
Number of unique values for the first field of the triple set.

<P>
<DT><STRONG>triples</STRONG>(<VAR>-Count</VAR>)<DD>
Total number of triples in the database.
</DL>

<P>
<DT><A NAME="rdf_match_label/3"><STRONG>rdf_match_label</STRONG>(<VAR>+Method, 
+Search, +Atom</VAR>)</A><DD>
True if <VAR>Search</VAR> matches <VAR>Atom</VAR> as defined by <VAR>Method</VAR>. 
All matching is performed case-insensitive. Defines methods are:

<DL>

<P>
<DT><STRONG>exact</STRONG><DD>
Perform exact, but case-insensitive match.

<P>
<DT><STRONG>substring</STRONG><DD>
<VAR>Search</VAR> is a sub-string of <VAR>Text</VAR>.

<P>
<DT><STRONG>word</STRONG><DD>
<VAR>Search</VAR> appears as a whole-word in <VAR>Text</VAR>.

<P>
<DT><STRONG>prefix</STRONG><DD>
<VAR>Text</VAR> start with <VAR>Search</VAR>.

<P>
<DT><STRONG>like</STRONG><DD>
<VAR>Text</VAR> matches <VAR>Search</VAR>, case insensitively, where the 
`*' character in <VAR>Search</VAR> matches zero or more characters.
</DL>

<P>
<DT><A NAME="rdf_reset_db/0"><STRONG>rdf_reset_db</STRONG></A><DD>
Erase all triples from the database and reset all counts and statistics 
information.

<P>
<DT><A NAME="rdf_version/1"><STRONG>rdf_version</STRONG>(<VAR>-Version</VAR>)</A><DD>
Unify <VAR>Version</VAR> with the library version number. This number 
is, like to the SWI-Prolog version flag, defined as <VAR>10,000 &times; 
Major + 100 &times; Minor + Patch</VAR>.
</DL>

<H3><A NAME="sec:3.7">3.7 Issues with rdf_db</A></H3>

<A NAME="sec:rdfissues"></A>

<P>This RDF low-level module has been created after two year 
experimenting with a plain Prolog based module and a brief evaluation of 
a second generation pure Prolog implementation. The aim was to be able 
to handle upto about 2 million triples on standard (notebook) hardware 
and deal efficiently with <CODE>subPropertyOf</CODE> which was 
identified as a crucial feature of RDFS to realise fusion of different 
data-sets.

<P>The following issues are identified and not solved in suitable 
manner.

<DL>

<P>
<DT><B>Logical update</B><DD>
as provided by Prolog means that active queries are not affected by 
subsequent modification of the database. The current C-based 
implementation adheres the <EM>immediate</EM> update model, mainly 
because the current foreign language interface does not provide the 
required information to realise logical updates in C.

<P>
<DT><B><CODE>subPropertyOf</CODE> of <CODE>subPropertyOf</CODE></B><DD>
is not supported.

<P>
<DT><B>Equivalence</B><DD>
Similar to <CODE>subPropertyOf</CODE>, it is likely to be profitable to 
handle resource identity efficient. The current system has no support 
for it.
</DL>

<H2><A NAME="sec:4">4 Module rdfs</A></H2>

<A NAME="sec:rdfs"></A>

<P><A NAME="idx:RDFSchema:53"></A>The <CODE>library(rdfs)</CODE> library 
adds interpretation of the triple store in terms of concepts from 
RDF-Schema (RDFS).

<H3><A NAME="sec:4.1">4.1 Hierarchy and class-individual relations</A></H3>

<P>The predicates in this section explore the <CODE>rdfs:subPropertyOf</CODE>,
<CODE>rdfs:subClassOf</CODE> and <CODE>rdf:type</CODE> relations. Note 
that the most fundamental of these, <CODE>rdfs:subPropertyOf</CODE>, is 
also used by <A NAME="idx:rdfhas34:54"></A><A HREF="#rdf_has/3">rdf_has/[3,4]</A>.

<DL>

<P>
<DT><A NAME="rdfs_subproperty_of/2"><STRONG>rdfs_subproperty_of</STRONG>(<VAR>?SubProperty, 
?Property</VAR>)</A><DD>
True if <VAR>SubProperty</VAR> is equal to <VAR>Property</VAR> or <VAR>Property</VAR> 
can be reached from <VAR>SubProperty</VAR> following the
<CODE>rdfs:subPropertyOf</CODE> relation. It can be used to test as well 
as generate sub-properties or super-properties. Note that the commonly 
used semantics of this predicate is wired into <A NAME="idx:rdfhas34:55"></A><A HREF="#rdf_has/3">rdf_has/[3,4]</A>.<A NAME=back-to-note-3 HREF="semweb.html#note-3"> (3)</A>.<A NAME=back-to-note-4 HREF="semweb.html#note-4"> (4)</A>

<P>
<DT><A NAME="rdfs_subclass_of/2"><STRONG>rdfs_subclass_of</STRONG>(<VAR>?SubClass, 
?Class</VAR>)</A><DD>
True if <VAR>SubClass</VAR> is equal to <VAR>Class</VAR> or <VAR>Class</VAR> 
can be reached from <VAR>SubClass</VAR> following the
<CODE>rdfs:subClassOf</CODE> relation. It can be used to test as well as 
generate sub-classes or super-classes.<A NAME=back-to-note-5 HREF="semweb.html#note-5"> (5)</A>.

<P>
<DT><A NAME="rdfs_class_property/2"><STRONG>rdfs_class_property</STRONG>(<VAR>+Class, 
?Property</VAR>)</A><DD>
True if the domain of <VAR>Property</VAR> includes <VAR>Class</VAR>. 
Used to generate all properties that apply to a class.

<P>
<DT><A NAME="rdfs_individual_of/2"><STRONG>rdfs_individual_of</STRONG>(<VAR>?Resource, 
?Class</VAR>)</A><DD>
True if <VAR>Resource</VAR> is an indivisual of <VAR>Class</VAR>. This 
implies
<VAR>Resource</VAR> has an <CODE>rdf:type</CODE> property that refers to
<VAR>Class</VAR> or a sub-class thereof. Can be used to test, generate 
classes <VAR>Resource</VAR> belongs to or generate individuals described 
by <VAR>Class</VAR>.
</DL>

<H3><A NAME="sec:4.2">4.2 Collections and Containers</A></H3>

<P><A NAME="idx:parseTypeCollection:56"></A><A NAME="idx:CollectionparseType:57"></A>The 
RDF construct <CODE>rdf:parseType</CODE>=<CODE>Collection</CODE> 
constructs a list using the <CODE>rdf:first</CODE> and <CODE>rdf:next</CODE> 
relations.

<DL>

<P>
<DT><A NAME="rdfs_member/2"><STRONG>rdfs_member</STRONG>(<VAR>?Resource, 
+Set</VAR>)</A><DD>
Test or generate the members of <VAR>Set</VAR>. <VAR>Set</VAR> is either 
an individual of <CODE>rdf:List</CODE> or <CODE>rdf:Container</CODE>.

<P>
<DT><A NAME="rdfs_list_to_prolog_list/2"><STRONG>rdfs_list_to_prolog_list</STRONG>(<VAR>+Set, 
-List</VAR>)</A><DD>
Convert <VAR>Set</VAR>, which must be an individual of <CODE>rdf:List</CODE> 
into a Prolog list of objects.

<P>
<DT><A NAME="rdfs_assert_list/2"><STRONG>rdfs_assert_list</STRONG>(<VAR>+List, 
-Resource</VAR>)</A><DD>
If <VAR>List</VAR> is a list of resources, create an RDF list <VAR>Resource</VAR> 
that reflects these resources. <VAR>Resource</VAR> and the sublist 
resources are generated with <A NAME="idx:rdfbnode1:58"></A><A HREF="#rdf_bnode/1">rdf_bnode/1</A>.
</DL>

<H3><A NAME="sec:4.3">4.3 Labels and textual search</A></H3>

<P>Textual search is partly handled by the predicates from the
<CODE>library(rdf_db)</CODE> module and its underlying C-library. For 
example, literal objects are hashed case-insensitive to speed up the 
commonly used case-insensitive search.

<DL>

<P>
<DT><A NAME="rdfs_label/3"><STRONG>rdfs_label</STRONG>(<VAR>?Resource, 
?Language, ?Label</VAR>)</A><DD>
Extract the label from <VAR>Resource</VAR> or generate all resources 
with the given <VAR>Label</VAR>. The label is either associated using a 
sub-property of <CODE>rdfs:label</CODE> or it is extracted from the URL 
using <A NAME="idx:rdfspliturl3:59"></A><A HREF="#rdf_split_url/3">rdf_split_url/3</A>. <VAR>Language</VAR> 
is unified to the value of the <CODE>xml:lang</CODE> attribute of the 
label or a variable if the label has no language specified.

<P>
<DT><A NAME="rdfs_label/2"><STRONG>rdfs_label</STRONG>(<VAR>?Resource, 
?Label</VAR>)</A><DD>
Defined as <CODE>rdfs_label(Resource, _, Label)</CODE>.

<P>
<DT><A NAME="rdfs_ns_label/3"><STRONG>rdfs_ns_label</STRONG>(<VAR>?Resource, 
?Language, ?Label</VAR>)</A><DD>
Similar to <A NAME="idx:rdfslabel2:60"></A><A HREF="#rdfs_label/2">rdfs_label/2</A>, 
but prefixes the result using the declared namespace alias (see <A HREF="#sec:rdfns">section 
3.5</A>) to facilitate user-friendly labels in applications using 
multiple namespaces that may lead to confusion.

<P>
<DT><A NAME="rdfs_ns_label/2"><STRONG>rdfs_ns_label</STRONG>(<VAR>?Resource, 
?Label</VAR>)</A><DD>
Defined as <CODE>rdfs_ns_label(Resource, _, Label)</CODE>.

<P>
<DT><A NAME="rdfs_find/5"><STRONG>rdfs_find</STRONG>(<VAR>+String, 
+Description, +Properties, +Method, -Subject</VAR>)</A><DD>
<A NAME="idx:search:61"></A>Find (on backtracking) <VAR>Subject</VAR>s 
that satisfy a search specification for textual attributes. <VAR>String</VAR> 
is the string searched for. <VAR>Description</VAR> is an OWL description 
(see <A HREF="#sec:owl">section 5</A>) specifying candidate resources. <VAR>Properties</VAR> 
is a list of properties to search for literal objects where <VAR>rdfs:label</VAR> 
is replaced by a call to <A NAME="idx:rdfslabel2:62"></A><A HREF="#rdfs_label/2">rdfs_label/2</A> 
and finally, <VAR>Method</VAR> defines the textual matching algorithm. 
All textual mapping is performed case-insensitive. The matching-methods 
are described with <A NAME="idx:rdfmatchlabel3:63"></A><A HREF="#rdf_match_label/3">rdf_match_label/3</A>.
</DL>

<H2><A NAME="sec:5">5 Module owl</A></H2>

<A NAME="sec:owl"></A>

<P><A NAME="idx:OWL:64"></A>The current SemWeb library distributed with 
SWI-Prolog does not yet contain an OWL module. A module <CODE>owl.pl</CODE> 
is part of the
<A HREF="http://www.swi-prolog.org/packages/Triple20/">Triple20</A> 
triple browser and editor provides limited support for OWL reasoning.

<H2><A NAME="sec:6">6 Module rdf_edit</A></H2>

<A NAME="sec:rdfedit"></A>

<P><A NAME="idx:undo:65"></A><A NAME="idx:journal:66"></A><A NAME="idx:transactions:67"></A>The 
module <CODE>rdf_edit.pl</CODE> is a layer than encasulates the 
modification predicates from <A HREF="#sec:rdfmodify">section 3.3</A> 
for use from a (graphical) editor of the triple store. It adds the 
following features:

<P>
<UL>
<LI><I>Transaction management</I><BR>
Modifications are grouped into <EM>transactions</EM> to safeguard the 
system from failing operations as well as provide meaningfull chunks for 
undo and journalling.

<P>
<LI><I>Undo</I><BR>
Undo and redo-transactions using a single mechanism to support 
user-friendly editing.

<P>
<LI><I>Journalling</I><BR>
Record all actions to support analysis, versioning, crash-recovery and 
an alternative to saving.
</UL>

<H3><A NAME="sec:6.1">6.1 Transaction management</A></H3>

<P>Transactions group low-level modification actions together.

<DL>

<P>
<DT><A NAME="rdfe_transaction/1"><STRONG>rdfe_transaction</STRONG>(<VAR>:Goal</VAR>)</A><DD>
Run <VAR>Goal</VAR>, recording all modifications to the triple store 
made through <A HREF="#sec:rdfeencap">section 6.3</A>. Execution is 
performed as in <A NAME="idx:once1:68"></A><B>once/1</B>. If
<VAR>Goal</VAR> succeeds the changes are committed. If <VAR>Goal</VAR> 
fails or throws an exception the changes are reverted.

<P>Transactions may be nested. A failing nested transaction only reverts 
the actions performed inside the nested transaction. If the outer 
transaction succeeds it is committed normally. Contrary, if the outer 
transaction fails, comitted nested transactions are reverted as well. If 
any of the modifications inside the transaction modifies a protected 
file (see <A NAME="idx:rdfesetfileproperty2:69"></A><A HREF="#rdfe_set_file_property/2">rdfe_set_file_property/2</A>) 
the transaction is reverted and <A NAME="idx:rdfetransaction1:70"></A><A HREF="#rdfe_transaction/1">rdfe_transaction/1</A> 
throws a permission error.

<P>A successful outer transaction (`level-0') may be undone using
<A NAME="idx:rdfeundo0:71"></A><A HREF="#rdfe_undo/0">rdfe_undo/0</A>.

<P>
<DT><A NAME="rdfe_transaction/2"><STRONG>rdfe_transaction</STRONG>(<VAR>:Goal, 
+Name</VAR>)</A><DD>
As <A NAME="idx:rdfetransaction1:72"></A><A HREF="#rdfe_transaction/1">rdfe_transaction/1</A>, 
naming the transaction <VAR>Name</VAR>. Transaction naming is intended 
for the GUI to give the user an idea of the next undo action. See also <A NAME="idx:rdfesettransactionname1:73"></A><A HREF="#rdfe_set_transaction_name/1">rdfe_set_transaction_name/1</A> 
and
<A NAME="idx:rdfetransactionname2:74"></A><A HREF="#rdfe_transaction_name/2">rdfe_transaction_name/2</A>.

<P>
<DT><A NAME="rdfe_set_transaction_name/1"><STRONG>rdfe_set_transaction_name</STRONG>(<VAR>+Name</VAR>)</A><DD>
Set the `name' of the current transaction to <VAR>Name</VAR>.

<P>
<DT><A NAME="rdfe_transaction_name/2"><STRONG>rdfe_transaction_name</STRONG>(<VAR>?TID, 
?Name</VAR>)</A><DD>
Query assigned transaction names.

<P>
<DT><A NAME="rdfe_transaction_member/2"><STRONG>rdfe_transaction_member</STRONG>(<VAR>+TID, 
-Action</VAR>)</A><DD>
Enumerate the actions that took place inside a transaction. This can be 
used by a GUI to optimise the MVC (Model-View-Controller) feedback loop. <VAR>Action</VAR> 
is one of:

<DL>

<P>
<DT><STRONG>assert</STRONG>(<VAR>Subject, Predicate, Object</VAR>)<DD>

<P>
<DT><STRONG>retract</STRONG>(<VAR>Subject, Predicate, Object</VAR>)<DD>

<P>
<DT><STRONG>update</STRONG>(<VAR>Subject, Predicate, Object, Action</VAR>)<DD>

<P>
<DT><STRONG>file</STRONG>(<VAR>load(Path)</VAR>)<DD>

<P>
<DT><STRONG>file</STRONG>(<VAR>unload(Path)</VAR>)<DD>
</DL>

</DL>

<H3><A NAME="sec:6.2">6.2 File management</A></H3>

<A NAME="sec:file"></A>

<DL>

<P>
<DT><A NAME="rdfe_is_modified/1"><STRONG>rdfe_is_modified</STRONG>(<VAR>?File</VAR>)</A><DD>
Enumerate/test whether <VAR>File</VAR> is modified sinds it was loaded 
or sinds the last call to <A NAME="idx:rdfeclearmodified1:75"></A><A HREF="#rdfe_clear_modified/1">rdfe_clear_modified/1</A>. 
Whether or not a file is modified is determined by the MD5 checksum of 
all triples belonging to the file.

<P>
<DT><A NAME="rdfe_clear_modified/1"><STRONG>rdfe_clear_modified</STRONG>(<VAR>+File</VAR>)</A><DD>
Set the <EM>unmodified-MD5</EM> to the current MD5 checksum. See also
<A NAME="idx:rdfeismodified1:76"></A><A HREF="#rdfe_is_modified/1">rdfe_is_modified/1</A>.

<P>
<DT><A NAME="rdfe_set_file_property/2"><STRONG>rdfe_set_file_property</STRONG>(<VAR>+File, 
+Property</VAR>)</A><DD>
Control access right and default destination of new triples.
<VAR>Property</VAR> is one of

<DL>

<P>
<DT><STRONG>access</STRONG>(<VAR>+Access</VAR>)<DD>
Where access is one of <CODE>ro</CODE> or <CODE>rw</CODE>. Access <CODE>ro</CODE> 
is default when a file is loaded for which the user has no write access. 
If a transaction (see <A NAME="idx:rdfetransaction1:77"></A><A HREF="#rdfe_transaction/1">rdfe_transaction/1</A>) 
modifies a file with access <CODE>ro</CODE> the transaction is reversed.

<P>
<DT><STRONG>default</STRONG>(<VAR>+Default</VAR>)<DD>
Set this file to be the default destination of triples. If
<VAR>Default</VAR> is <CODE>fallback</CODE> it is only the default for 
triples that have no clear default destination. If it is <CODE>all</CODE> 
all new triples are added to this file.
</DL>

<P>
<DT><A NAME="rdfe_get_file_property/2"><STRONG>rdfe_get_file_property</STRONG>(<VAR>?File, 
?Property</VAR>)</A><DD>
Query properties set with <A NAME="idx:rdfesetfileproperty2:78"></A><A HREF="#rdfe_set_file_property/2">rdfe_set_file_property/2</A>.
</DL>

<H3><A NAME="sec:6.3">6.3 Encapsulated predicates</A></H3>

<A NAME="sec:rdfeencap"></A>

<P>The following predicates encapsulate predicates from the <CODE>rdf_db</CODE> 
module that modify the triple store. These predicates can only be called 
when inside a <EM>transaction</EM>. See <A NAME="idx:rdfetransaction1:79"></A><A HREF="#rdfe_transaction/1">rdfe_transaction/1</A>.

<DL>

<P>
<DT><A NAME="rdfe_assert/3"><STRONG>rdfe_assert</STRONG>(<VAR>+Subject, 
+Predicate, +Object</VAR>)</A><DD>
Encapsulates <A NAME="idx:rdfassert3:80"></A><A HREF="#rdf_assert/3">rdf_assert/3</A>.

<P>
<DT><A NAME="rdfe_retractall/3"><STRONG>rdfe_retractall</STRONG>(<VAR>?Subject, 
?Predicate, ?Object</VAR>)</A><DD>
Encapsulates <A NAME="idx:rdfretractall3:81"></A><A HREF="#rdf_retractall/3">rdf_retractall/3</A>.

<P>
<DT><A NAME="rdfe_update/4"><STRONG>rdfe_update</STRONG>(<VAR>+Subject, 
+Predicate, +Object, +Action</VAR>)</A><DD>
Encapsulates <A NAME="idx:rdfupdate4:82"></A><A HREF="#rdf_update/4">rdf_update/4</A>.

<P>
<DT><A NAME="rdfe_load/1"><STRONG>rdfe_load</STRONG>(<VAR>+In</VAR>)</A><DD>
Encapsulates <A NAME="idx:rdfload1:83"></A><A HREF="#rdf_load/1">rdf_load/1</A>.

<P>
<DT><A NAME="rdfe_unload/1"><STRONG>rdfe_unload</STRONG>(<VAR>+In</VAR>)</A><DD>
Encapsulates <A NAME="idx:rdfunload1:84"></A><A HREF="#rdf_unload/1">rdf_unload/1</A>.
</DL>

<H3><A NAME="sec:6.4">6.4 High-level modification predicates</A></H3>

<A NAME="sec:rdfeedit"></A>

<P>This section describes a (yet very incomplete) set of more high-level 
operations one would like to be able to perform. Eventually this set may 
include operations based on RDFS and OWL.

<DL>

<P>
<DT><A NAME="rdfe_delete/1"><STRONG>rdfe_delete</STRONG>(<VAR>+Resource</VAR>)</A><DD>
Delete all traces of <VAR>resource</VAR>. This implies all triples where
<VAR>Resource</VAR> appears as <EM>subject</EM>, <EM>predicate</EM> or
<EM>object</EM>. This predicate starts a transation.
</DL>

<H3><A NAME="sec:6.5">6.5 Undo</A></H3>

<P><A NAME="idx:undo:85"></A>Undo aims at user-level undo operations 
from a (graphical) editor.

<DL>

<P>
<DT><A NAME="rdfe_undo/0"><STRONG>rdfe_undo</STRONG></A><DD>
Revert the last outermost (`level 0') transaction (see
<A NAME="idx:rdfetransaction1:86"></A><A HREF="#rdfe_transaction/1">rdfe_transaction/1</A>). 
Successive calls go further back in history. Fails if there is no more 
undo information.

<P>
<DT><A NAME="rdfe_redo/0"><STRONG>rdfe_redo</STRONG></A><DD>
Revert the last <A NAME="idx:rdfeundo0:87"></A><A HREF="#rdfe_undo/0">rdfe_undo/0</A>. 
Successive calls revert more <A NAME="idx:rdfeundo0:88"></A><A HREF="#rdfe_undo/0">rdfe_undo/0</A> 
operations. Fails if there is no more redo information.

<P>
<DT><A NAME="rdfe_can_undo/1"><STRONG>rdfe_can_undo</STRONG>(<VAR>-TID</VAR>)</A><DD>
Test if there is another transaction that can be reverted. Used for 
activating menus in a graphical environment. <VAR>TID</VAR> is unified 
to the transaction id of the action that will be reverted.

<P>
<DT><A NAME="rdfe_can_redo/1"><STRONG>rdfe_can_redo</STRONG>(<VAR>-TID</VAR>)</A><DD>
Test if there is another undo that can be reverted. Used for activating 
menus in a graphical environment. <VAR>TID</VAR> is unified to the 
transaction id of the action that will be reverted.
</DL>

<H3><A NAME="sec:6.6">6.6 Journalling</A></H3>

<P><A NAME="idx:journal:89"></A>Optionally, every action through this 
module is immediately send to a
<EM>journal-file</EM>. The journal provides a full log of all actions 
with a time-stamp that may be used for inspection of behaviour, version 
management, crash-recovery or an alternative to regular save operations.

<DL>

<P>
<DT><A NAME="rdfe_open_journal/2"><STRONG>rdfe_open_journal</STRONG>(<VAR>+File, 
+Mode</VAR>)</A><DD>
Open a existing or new journal. If <VAR>Mode</VAR> equala <CODE>append</CODE> 
and <VAR>File</VAR> exists, the journal is first replayed. See
<A NAME="idx:rdfereplayjournal1:90"></A><A HREF="#rdfe_replay_journal/1">rdfe_replay_journal/1</A>. 
If <VAR>Mode</VAR> is <CODE>write</CODE> the journal is truncated if it 
exists.

<P>
<DT><A NAME="rdfe_close_journal/0"><STRONG>rdfe_close_journal</STRONG></A><DD>
Close the currently open journal.

<P>
<DT><A NAME="rdfe_current_journal/1"><STRONG>rdfe_current_journal</STRONG>(<VAR>-Path</VAR>)</A><DD>
Test whether there is a journal and to which file the actions are 
journalled.

<P>
<DT><A NAME="rdfe_replay_journal/1"><STRONG>rdfe_replay_journal</STRONG>(<VAR>+File</VAR>)</A><DD>
Read a jorunal, replaying all actions in it. To do so, the system reads 
the journal a transaction at a time. If the transaction is closed with a <EM>commit</EM> 
it executes the actions inside the journal. If it is closed with a <EM>rollback</EM> 
or not closed at all due to a crash the actions inside the journal are 
discarded. Using this predicate only makes sense to inspect the state at 
the end of a journal without modifying the journal. Normally a journal 
is replayed using the
<CODE>append</CODE> mode of <A NAME="idx:rdfeopenjournal2:91"></A><A HREF="#rdfe_open_journal/2">rdfe_open_journal/2</A>.
</DL>

<H3><A NAME="sec:6.7">6.7 Broadcasting change events</A></H3>

<P><A NAME="idx:event:92"></A><A NAME="idx:broadcast:93"></A>To realise 
a modular graphical interface for editing the triple store, the system 
must use some sort of <EM>event</EM> mechanism. This is implemented by 
the XPCE library <CODE>library(broadcast)</CODE> which is described in 
the <A HREF="http://www.swi.psy.uva.nl/projects/xpce/UserGuide/libbroadcast.html">XPCE 
User Guide</A>. In this section we describe the terms brodcasted by the 
library.

<DL>

<P>
<DT><STRONG>rdf_transaction</STRONG>(<VAR>+Id</VAR>)<DD>
A `level-0' transaction has been committed. The system passes the 
identifier of the transaction in <VAR>Id</VAR>. In the current 
implementation there is no way to find out what happened inside the 
transaction. This is likely to change in time.

<P>If a transaction is reverted due to failure or exception <EM>no</EM> 
event is broadcasted. The initiating GUI element is supposed to handle 
this possibility itself and other components are not affected as the 
triple store is not changed.

<P>
<DT><STRONG>rdf_undo</STRONG>(<VAR>+Type, +Id</VAR>)<DD>
This event is broadcasted after an <A NAME="idx:rdfeundo0:94"></A><A HREF="#rdfe_undo/0">rdfe_undo/0</A> 
or <A NAME="idx:rdferedo0:95"></A><A HREF="#rdfe_redo/0">rdfe_redo/0</A>.
<VAR>Type</VAR> is one of <CODE>undo</CODE> or <CODE>redo</CODE> and <VAR>Id</VAR> 
identifies the transaction as above.
</DL>

<H2><A NAME="sec:7">7 Related packages and issues</A></H2>

<P><A NAME="idx:Sesame:96"></A><A NAME="idx:SeRQL:97"></A>The SWI-Prolog 
SemWeb package is designed to provide access to the Semantic Web 
languages from Prolog. It consists of the low level
<CODE>rdf_db.pl</CODE> store with layers such as <CODE>rdfs.pl</CODE> to 
provide more high level querying of a triple set with relations such as
<A NAME="idx:rdfsindividualof2:98"></A><A HREF="#rdfs_individual_of/2">rdfs_individual_of/2</A>, <A NAME="idx:rdfssubclassof2:99"></A><A HREF="#rdfs_subclass_of/2">rdfs_subclass_of/2</A>, 
etc.
<A HREF="http://www.openrdf.org">SeRQL</A> is a semantic web query 
language taking another route. Instead of providing alternative 
relations SeRQL defines a graph query on de <EM>deductive closure</EM> 
of the triple set. For example, under assumption of RDFS entailment 
rules this makes the query <CODE>rdf(S, rdf:type, Class)</CODE> 
equivalent to
<CODE>rdfs_individual_of(S, Class)</CODE>.

<P><A NAME="idx:optimisingquery:100"></A>We developed a parser for SeRQL 
which compiles SeRQL path expressions into Prolog conjunctions of <CODE>rdf(Subject, 
Predicate, Object)</CODE> calls. <EM>Entailment modules</EM> realise a 
fully logical implementation of <A NAME="idx:rdf3:101"></A><A HREF="#rdf/3">rdf/3</A> 
including the entailment reasoning required to deal with a Semantic Web 
language or application specific reasoning. The infra structure is 
completed with a query optimiser and an HTTP server compliant to the <A HREF="http://www.openrdf.org">Sesame</A> 
implementation of the SeRQL language. The Sesame Java client can be used 
to access Prolog servers from Java, while the Prolog client can be used 
to access the Sesame SeRQL server. For further details, see the
<A HREF="http://gollem.swi.psy.uva.nl/twiki/pl/bin/view/Library/SeRQL">project 
home</A>.

<H1><A NAME="document-notes">Footnotes</A></H1>

<DL>

<P>
<DT><A NAME=note-1 HREF="semweb.html#back-to-note-1">note-1</A><DD>
The orginal implementation was in Prolog. This version was implemented 
in 3 hours, where the C-based implementation costed a full week. The 
C-based implementation requires about half the memory and provides about 
twice the performance.
<DT><A NAME=note-2 HREF="semweb.html#back-to-note-2">note-2</A><DD>
This predicate realises semantics defined in RDF-Schema rather than RDF. 
It is part of the <CODE>library(rdf_db)</CODE> module because the 
indexing of this module incorporates the <CODE>rdfs:subClassOf</CODE> 
predicate.
<DT><A NAME=note-3 HREF="semweb.html#back-to-note-3">note-3</A><DD>
BUG: The current implementation cannot deal with cycles
<DT><A NAME=note-4 HREF="semweb.html#back-to-note-4">note-4</A><DD>
BUG: The current implementation cannot deal with predicates that are an <CODE>rdfs:subPropertyOf</CODE> 
of <CODE>rdfs:subPropertyOf</CODE>, such as <CODE>owl:samePropertyAs</CODE>.
<DT><A NAME=note-5 HREF="semweb.html#back-to-note-5">note-5</A><DD>
BUG: The current implementation cannot deal with cycles
</DL>

<H1><A NAME="document-index">Index</A></H1>

<DL>

<P>
<DT><STRONG>A</STRONG><DD>
<DT>atom_concat/3<DD>
<A HREF="#idx:atomconcat3:48">3.5</A>
<DT><STRONG>B</STRONG><DD>
<DT>broadcast<DD>
<A HREF="#idx:broadcast:93">6.7</A>
<DT><STRONG>C</STRONG><DD>
<DT>Collection,parseType<DD>
<A HREF="#idx:CollectionparseType:57">4.2</A>
<DT><STRONG>E</STRONG><DD>
<DT>event<DD>
<A HREF="#idx:event:92">6.7</A>
<DT>expand_goal/2<DD>
<A HREF="#idx:expandgoal2:3">3.1</A>
<DT><STRONG>G</STRONG><DD>
<DT>goal_expansion/2<DD>
<A HREF="#idx:goalexpansion2:44">3.5</A> <A HREF="#idx:goalexpansion2:45">3.5</A>
<DT><STRONG>J</STRONG><DD>
<DT>journal<DD>
<A HREF="#idx:journal:66">6</A> <A HREF="#idx:journal:89">6.6</A>
<DT><STRONG>O</STRONG><DD>
<DT>once/1<DD>
<A HREF="#idx:once1:68">6.1</A>
<DT>optimising,query<DD>
<A HREF="#idx:optimisingquery:100">7</A>
<DT>OWL<DD>
<A HREF="#idx:OWL:64">5</A>
<DT><STRONG>P</STRONG><DD>
<DT>parseType,Collection<DD>
<A HREF="#idx:parseTypeCollection:56">4.2</A>
<DT>process_rdf/3<DD>
<A HREF="#idx:processrdf3:29">3.4</A> <A HREF="#idx:processrdf3:33">3.4</A>
<DT><STRONG>R</STRONG><DD>
<DT><A HREF="#rdf/3">rdf/3</A><DD>
<A HREF="#idx:rdf3:2">3</A> <A HREF="#idx:rdf3:5">3.1</A> <A HREF="#idx:rdf3:6">3.1</A> <A HREF="#idx:rdf3:10">3.2</A> <A HREF="#idx:rdf3:14">3.3.1</A> <A HREF="#idx:rdf3:25">3.3.2</A> <A HREF="#idx:rdf3:47">3.5</A> <A HREF="#idx:rdf3:101">7</A>
<DT><A HREF="#rdf/4">rdf/4</A><DD>
<A HREF="#idx:rdf4:4">3.1</A>
<DT><A HREF="#rdf_assert/3">rdf_assert/3</A><DD>
<A HREF="#idx:rdfassert3:15">3.3.1</A> <A HREF="#idx:rdfassert3:22">3.3.2</A> <A HREF="#idx:rdfassert3:38">3.4.2</A> <A HREF="#idx:rdfassert3:80">6.3</A>
<DT><A HREF="#rdf_assert/4">rdf_assert/4</A><DD>
<A HREF="#idx:rdfassert4:13">3.3.1</A>
<DT>rdf_assert/[3,4]<DD>
<A HREF="#idx:rdfassert34:41">3.4.3</A>
<DT><A HREF="#rdf_atom_md5/3">rdf_atom_md5/3</A><DD>
<DT><A HREF="#rdf_bnode/1">rdf_bnode/1</A><DD>
<A HREF="#idx:rdfbnode1:58">4.2</A>
<DT><A HREF="#rdfe_assert/3">rdfe_assert/3</A><DD>
<DT><A HREF="#rdfe_can_redo/1">rdfe_can_redo/1</A><DD>
<DT><A HREF="#rdfe_can_undo/1">rdfe_can_undo/1</A><DD>
<DT><A HREF="#rdfe_clear_modified/1">rdfe_clear_modified/1</A><DD>
<A HREF="#idx:rdfeclearmodified1:75">6.2</A>
<DT><A HREF="#rdfe_close_journal/0">rdfe_close_journal/0</A><DD>
<DT><A HREF="#rdfe_current_journal/1">rdfe_current_journal/1</A><DD>
<DT><A HREF="#rdfe_delete/1">rdfe_delete/1</A><DD>
<DT><A HREF="#rdfe_get_file_property/2">rdfe_get_file_property/2</A><DD>
<DT><A HREF="#rdfe_is_modified/1">rdfe_is_modified/1</A><DD>
<A HREF="#idx:rdfeismodified1:76">6.2</A>
<DT><A HREF="#rdfe_load/1">rdfe_load/1</A><DD>
<DT><A HREF="#rdfe_open_journal/2">rdfe_open_journal/2</A><DD>
<A HREF="#idx:rdfeopenjournal2:91">6.6</A>
<DT><A HREF="#rdf_equal/2">rdf_equal/2</A><DD>
<DT><A HREF="#rdfe_redo/0">rdfe_redo/0</A><DD>
<A HREF="#idx:rdferedo0:95">6.7</A>
<DT><A HREF="#rdfe_replay_journal/1">rdfe_replay_journal/1</A><DD>
<A HREF="#idx:rdfereplayjournal1:90">6.6</A>
<DT><A HREF="#rdfe_retractall/3">rdfe_retractall/3</A><DD>
<DT><A HREF="#rdfe_set_file_property/2">rdfe_set_file_property/2</A><DD>
<A HREF="#idx:rdfesetfileproperty2:69">6.1</A> <A HREF="#idx:rdfesetfileproperty2:78">6.2</A>
<DT><A HREF="#rdfe_set_transaction_name/1">rdfe_set_transaction_name/1</A><DD>
<A HREF="#idx:rdfesettransactionname1:73">6.1</A>
<DT><A HREF="#rdf_estimate_complexity/?Subject, ?Predicate, ?Object, -Complexity">rdf_estimate_complexity/?Subject, 
?Predicate, ?Object, -Complexity</A><DD>
<DT><A HREF="#rdfe_transaction/1">rdfe_transaction/1</A><DD>
<A HREF="#idx:rdfetransaction1:70">6.1</A> <A HREF="#idx:rdfetransaction1:72">6.1</A> <A HREF="#idx:rdfetransaction1:77">6.2</A> <A HREF="#idx:rdfetransaction1:79">6.3</A> <A HREF="#idx:rdfetransaction1:86">6.5</A>
<DT><A HREF="#rdfe_transaction/2">rdfe_transaction/2</A><DD>
<DT><A HREF="#rdfe_transaction_member/2">rdfe_transaction_member/2</A><DD>
<DT><A HREF="#rdfe_transaction_name/2">rdfe_transaction_name/2</A><DD>
<A HREF="#idx:rdfetransactionname2:74">6.1</A>
<DT><A HREF="#rdfe_undo/0">rdfe_undo/0</A><DD>
<A HREF="#idx:rdfeundo0:71">6.1</A> <A HREF="#idx:rdfeundo0:87">6.5</A> <A HREF="#idx:rdfeundo0:88">6.5</A> <A HREF="#idx:rdfeundo0:94">6.7</A>
<DT><A HREF="#rdfe_unload/1">rdfe_unload/1</A><DD>
<DT><A HREF="#rdfe_update/4">rdfe_update/4</A><DD>
<DT><A HREF="#rdf_generation/1">rdf_generation/1</A><DD>
<A HREF="#idx:rdfgeneration1:19">3.3.1</A>
<DT><A HREF="#rdf_global_id/2">rdf_global_id/2</A><DD>
<A HREF="#idx:rdfglobalid2:46">3.5</A>
<DT><A HREF="#rdf_global_object/2">rdf_global_object/2</A><DD>
<DT><A HREF="#rdf_global_term/2">rdf_global_term/2</A><DD>
<DT><A HREF="#rdf_has/3">rdf_has/3</A><DD>
<A HREF="#idx:rdfhas3:8">3.1</A> <A HREF="#idx:rdfhas3:11">3.2</A> <A HREF="#idx:rdfhas3:12">3.2</A> <A HREF="#idx:rdfhas3:49">3.6</A>
<DT><A HREF="#rdf_has/4">rdf_has/4</A><DD>
<A HREF="#idx:rdfhas4:1">3</A> <A HREF="#idx:rdfhas4:7">3.1</A>
<DT>rdf_has/[3,4]<DD>
<A HREF="#idx:rdfhas34:54">4.1</A> <A HREF="#idx:rdfhas34:55">4.1</A>
<DT><A HREF="#rdf_is_bnode/1">rdf_is_bnode/1</A><DD>
<DT><A HREF="#rdf_load/1">rdf_load/1</A><DD>
<A HREF="#idx:rdfload1:30">3.4</A> <A HREF="#idx:rdfload1:32">3.4</A> <A HREF="#idx:rdfload1:34">3.4</A> <A HREF="#idx:rdfload1:52">3.6</A> <A HREF="#idx:rdfload1:83">6.3</A>
<DT><A HREF="#rdf_load/2">rdf_load/2</A><DD>
<DT>rdf_load/[1,2]<DD>
<A HREF="#idx:rdfload12:37">3.4.2</A> <A HREF="#idx:rdfload12:39">3.4.3</A> <A HREF="#idx:rdfload12:43">3.4.3</A>
<DT><A HREF="#rdf_load_db/1">rdf_load_db/1</A><DD>
<A HREF="#idx:rdfloaddb1:31">3.4</A> <A HREF="#idx:rdfloaddb1:40">3.4.3</A>
<DT><A HREF="#rdf_make/0">rdf_make/0</A><DD>
<DT><A HREF="#rdf_match_label/3">rdf_match_label/3</A><DD>
<A HREF="#idx:rdfmatchlabel3:63">4.3</A>
<DT><A HREF="#rdf_md5/2">rdf_md5/2</A><DD>
<DT><A HREF="#rdf_node/1">rdf_node/1</A><DD>
<DT><A HREF="#rdf_predicate_property/2">rdf_predicate_property/2</A><DD>
<A HREF="#idx:rdfpredicateproperty2:9">3.2</A> <A HREF="#idx:rdfpredicateproperty2:50">3.6</A>
<DT><A HREF="#rdf_reachable/3">rdf_reachable/3</A><DD>
<DT><A HREF="#rdf_register_ns/2">rdf_register_ns/2</A><DD>
<DT><A HREF="#rdf_reset_db/0">rdf_reset_db/0</A><DD>
<DT><A HREF="#rdf_retractall/3">rdf_retractall/3</A><DD>
<A HREF="#idx:rdfretractall3:16">3.3.1</A> <A HREF="#idx:rdfretractall3:81">6.3</A>
<DT><A HREF="#rdf_retractall/4">rdf_retractall/4</A><DD>
<A HREF="#idx:rdfretractall4:17">3.3.1</A> <A HREF="#idx:rdfretractall4:18">3.3.1</A>
<DT>rdf_retractall/[3,4]<DD>
<A HREF="#idx:rdfretractall34:42">3.4.3</A>
<DT><A HREF="#rdfs_assert_list/2">rdfs_assert_list/2</A><DD>
<DT><A HREF="#rdf_save/1">rdf_save/1</A><DD>
<DT><A HREF="#rdf_save/2">rdf_save/2</A><DD>
<DT><A HREF="#rdf_save_db/1">rdf_save_db/1</A><DD>
<DT><A HREF="#rdf_save_footer/1">rdf_save_footer/1</A><DD>
<DT><A HREF="#rdf_save_header/2">rdf_save_header/2</A><DD>
<A HREF="#idx:rdfsaveheader2:36">3.4.1</A>
<DT><A HREF="#rdf_save_subject/3">rdf_save_subject/3</A><DD>
<DT>RDF-Schema<DD>
<A HREF="#idx:RDFSchema:53">4</A>
<DT><A HREF="#rdfs_class_property/2">rdfs_class_property/2</A><DD>
<DT><A HREF="#rdf_set_predicate/2">rdf_set_predicate/2</A><DD>
<DT><A HREF="#rdfs_find/5">rdfs_find/5</A><DD>
<DT><A HREF="#rdfs_individual_of/2">rdfs_individual_of/2</A><DD>
<A HREF="#idx:rdfsindividualof2:98">7</A>
<DT><A HREF="#rdfs_label/2">rdfs_label/2</A><DD>
<A HREF="#idx:rdfslabel2:60">4.3</A> <A HREF="#idx:rdfslabel2:62">4.3</A>
<DT><A HREF="#rdfs_label/3">rdfs_label/3</A><DD>
<DT><A HREF="#rdfs_list_to_prolog_list/2">rdfs_list_to_prolog_list/2</A><DD>
<DT><A HREF="#rdfs_member/2">rdfs_member/2</A><DD>
<DT><A HREF="#rdfs_ns_label/2">rdfs_ns_label/2</A><DD>
<DT><A HREF="#rdfs_ns_label/3">rdfs_ns_label/3</A><DD>
<DT><A HREF="#rdf_source/1">rdf_source/1</A><DD>
<A HREF="#idx:rdfsource1:35">3.4</A>
<DT><A HREF="#rdf_source_location/2">rdf_source_location/2</A><DD>
<DT><A HREF="#rdf_split_url/3">rdf_split_url/3</A><DD>
<A HREF="#idx:rdfspliturl3:59">4.3</A>
<DT><A HREF="#rdfs_subclass_of/2">rdfs_subclass_of/2</A><DD>
<A HREF="#idx:rdfssubclassof2:99">7</A>
<DT><A HREF="#rdfs_subproperty_of/2">rdfs_subproperty_of/2</A><DD>
<DT><A HREF="#rdf_statistics/1">rdf_statistics/1</A><DD>
<A HREF="#idx:rdfstatistics1:51">3.6</A>
<DT><A HREF="#rdf_subject/1">rdf_subject/1</A><DD>
<DT><A HREF="#rdf_transaction/1">rdf_transaction/1</A><DD>
<A HREF="#idx:rdftransaction1:23">3.3.2</A> <A HREF="#idx:rdftransaction1:24">3.3.2</A> <A HREF="#idx:rdftransaction1:26">3.3.2</A> <A HREF="#idx:rdftransaction1:27">3.3.2</A> <A HREF="#idx:rdftransaction1:28">3.3.2</A>
<DT><A HREF="#rdf_unload/1">rdf_unload/1</A><DD>
<A HREF="#idx:rdfunload1:84">6.3</A>
<DT><A HREF="#rdf_update/4">rdf_update/4</A><DD>
<A HREF="#idx:rdfupdate4:20">3.3.1</A> <A HREF="#idx:rdfupdate4:82">6.3</A>
<DT><A HREF="#rdf_update/5">rdf_update/5</A><DD>
<DT><A HREF="#rdf_version/1">rdf_version/1</A><DD>
<DT><STRONG>S</STRONG><DD>
<DT>search<DD>
<A HREF="#idx:search:61">4.3</A>
<DT>SeRQL<DD>
<A HREF="#idx:SeRQL:97">7</A>
<DT>Sesame<DD>
<A HREF="#idx:Sesame:96">7</A>
<DT><STRONG>T</STRONG><DD>
<DT>transaction<DD>
<A HREF="#idx:transaction:21">3.3.2</A>
<DT>transactions<DD>
<A HREF="#idx:transactions:67">6</A>
<DT><STRONG>U</STRONG><DD>
<DT>undo<DD>
<A HREF="#idx:undo:65">6</A> <A HREF="#idx:undo:85">6.5</A>
</DL>

</BODY></HTML>